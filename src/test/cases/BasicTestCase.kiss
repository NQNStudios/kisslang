// (defvar) declares static variables
(defvar message "Howdy")

// #| ... |# parses and injects raw Haxe code
(defvar mathResult #|5 + 6 * 3|#) // Order of operations will apply

// (defun) declares static functions
(defun myFloor [num] 
    // funcalls can use dot access
    (Math.floor num))

// functions are resolved in the macro context
(defvar funResult (myFloor 7.5))

// (defprop) declares instance variables
(defprop myField 5)

// (defmethod) declares instance methods
(defmethod myMethod [] this.myField)

// [...] returns a Kiss array (they have special features and convert implicitly)
(defvar myArray [1 2 3])

// Array access is via nth
(defvar myArrayLast (nth myArray -1))

// Variadic math uses haxe's Lambda.fold under the hood
(defvar mySum (+ 1 2 3))

(defvar myDifference (- 5 4 3))

(defvar myProduct (* 2 5 6))

(defvar myQuotient (/ 6 3 2 2))

(defvar myRemainder (% 10 6))

(defvar myPower (^ 2 8))

(defvar &mut myNum 6)
(defvar myInc ++myNum)

(defvar myMin (min 9 3 7 1))
(defvar myMax (max 9 3 7 1))

(defvar myComp1 (< 1 2 3 4))
(defvar myComp2 (< 1 1 3 4))
(defvar myComp3 (<= 1 2 3 4))
(defvar myComp4 (<= 1 1 3 4))
(defvar myComp5 (> 4 3 2 1))
(defvar myComp6 (> 4 4 2 1))
(defvar myComp7 (>= 4 3 2 1))
(defvar myComp8 (>= 4 4 2 1))
(defvar myComp9 (= 1 1 1 1))
(defvar myComp10 (= 1 2 1 1))

(defvar myIf1 (if 1 true false))
(defvar myIf2 (if 0 true false))
(defvar myIf3 (if -1 true false))
(defvar myIf4 (if null true false))
(defvar myIf5 (if true true false))
(defvar myIf6 (if false true false))
(defvar myIf7 (if "string" true false))
(defvar myIf8 (if "" true false))
(defvar myIf9 (if [] true false))
(defvar myIf10 (if [1] true false))
(defvar myIf11 (if true 5))
(defvar myIf12 (if false 5))

(defvar :Int myInt 8)

(defmacrofun doTwiceInt [intOp]
    ,intOp
    ,intOp)

// I think this causes doTwiceInt's runtime function to be typed as requiring Quote<Int> and returning Int
(defun :Int incrementTwice [:Int val]
    (doTwiceInt ++val))

(defmacrofun doTwiceString [stringOp]
    ,stringOp
    ,stringOp)

(defun myTryCatch [:Any e]
    (try
        (throw e)
        (catch [:String error] 5)
        (catch [:Int error] 6)
        (catch [error] 7)))

(defun myTypeCheck []
    (the Int 5))

(defun myGroups1 []
    (Prelude.groups [1 2 3 4] 2))

(defun myGroups2 []
    (Prelude.groups [1 2 3 4] 3 true))

(defun _testLet []
    (let [a 5
            b 6
            :String c "stuff"]
        (Assert.equals 5 a)
        (Assert.equals 6 b)
        (Assert.equals "stuff" c))
    (let [&mut a "str1"]
        (Assert.equals "str1" a)
        (set a "str2")
        (Assert.equals "str2" a)))

(defvar myConstructedString (new String "sup"))

(defvar myCond1 (cond 
    ((= 5 6) "not this")
    ((= 8 9) "not this either")
    ((= 1 1) "this one")
    (true "not the default")))

(defvar myCond2 (cond 
    ((= 5 6) "not this")
    ((= 8 9) "not this either")
    ((= 2 1) "not the third one")
    (true "the default")))

(defvar myCond3 (cond
    ((= 5 5) "this")
    (true "default")))

(defvar myCondFallthrough (cond
    (false "not this")))

(defvar myOr1 (or null 5))

(defvar myAnd1 (and 5 6))
(defvar myAnd2 (and false 5 6))
(defvar myAnd3 (and 5 false 6))

(defun mySetLocal []
    (deflocal &mut loc "one thing")
    (set loc "another thing")
    loc)

(defvar myNot1 (not 5))
(defvar myNot2 !5)

(defvar myFilteredList (begin 
    (deflocal l [-1 -2 5 -3 6])
    (l.filter (lambda [v] (< 0 v)))))

(defvar myWhen1 (when true 5 6))

(defvar myListOfTen [1 2 3 4 5 6 7 8 9 10])

(defun _testQuickNths []
    (Assert.equals 1 (first myListOfTen))
    (Assert.equals 2 (second myListOfTen))
    (Assert.equals 3 (third myListOfTen))
    (Assert.equals 4 (fourth myListOfTen))
    (Assert.equals 5 (fifth myListOfTen))
    (Assert.equals 6 (sixth myListOfTen))
    (Assert.equals 7 (seventh myListOfTen))
    (Assert.equals 8 (eighth myListOfTen))
    (Assert.equals 9 (ninth myListOfTen))
    (Assert.equals 10 (tenth myListOfTen))
    (Assert.equals 10 (last myListOfTen)))

(defun _testListDestructuring []
    (deflocal [a b c d &mut e f g h i j] myListOfTen)
    (Assert.equals 1 a)
    (Assert.equals 2 b)
    (Assert.equals 3 c)
    (Assert.equals 4 d)
    (Assert.equals 5 e)
    (set e 6)
    (Assert.equals 6 e)
    (Assert.equals 6 f)
    (Assert.equals 7 g)
    (Assert.equals 8 h)
    (Assert.equals 9 i)
    (Assert.equals 10 j)

    (let [[a b c &mut d e f g h i j] myListOfTen]
        (Assert.equals 1 a)
        (Assert.equals 2 b)
        (Assert.equals 3 c)
        (Assert.equals 4 d)
        (set d 6)
        (Assert.equals 6 d)
        (Assert.equals 5 e)
        (Assert.equals 6 f)
        (Assert.equals 7 g)
        (Assert.equals 8 h)
        (Assert.equals 9 i)
        (Assert.equals 10 j)))


(defvar myMetaList [myListOfTen myListOfTen myListOfTen])

(defun _testDoFor []
    (deflocal &mut c 0)
    (doFor v myListOfTen
        (Assert.equals (+ c 1) v)
        (set c v))
    (doFor [a b c d e f g h i j] myMetaList
        (Assert.equals 1 a)
        (Assert.equals 2 b)
        (Assert.equals 3 c)
        (Assert.equals 4 d)
        (Assert.equals 5 e)
        (Assert.equals 6 f)
        (Assert.equals 7 g)
        (Assert.equals 8 h)
        (Assert.equals 9 i)
        (Assert.equals 10 j)))

(defun _testFor []
    (deflocal incrementedList (for v myListOfTen (+ 1 v)))
    (let [[a b c d e f g h i j] incrementedList]
        (Assert.equals 2 a)
        (Assert.equals 3 b)
        (Assert.equals 4 c)
        (Assert.equals 5 d)
        (Assert.equals 6 e)
        (Assert.equals 7 f)
        (Assert.equals 8 g)
        (Assert.equals 9 h)
        (Assert.equals 10 i)
        (Assert.equals 11 j))
    (deflocal smallerMetaList (for [a b c d e f g h i j] myMetaList [a e i]))
    (doFor [a e i] smallerMetaList
        (Assert.equals 1 a)
        (Assert.equals 5 e)
        (Assert.equals 10 i)))