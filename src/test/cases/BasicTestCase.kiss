// (defvar) declares static variables
(defvar message "Howdy")

// #| ... |# parses and injects raw Haxe code
(defvar mathResult #|5 + 6 * 3|#) // Order of operations will apply

// (defun) declares static functions
(defun myFloor [num] 
    // funcalls can use dot access
    (Math.floor num))

// functions are resolved in the macro context
(defvar funResult (myFloor 7.5))

// (defprop) declares instance variables
(defprop myField 5)

// (defmethod) declares instance methods
(defmethod myMethod [] this.myField)

// [...] returns a Kiss array (they have special features and convert implicitly)
(defvar myArray [1 2 3])

// Array access is via nth
(defvar myArrayLast (nth myArray -1))

// Variadic math uses haxe's Lambda.fold under the hood
(defvar mySum (+ 1 2 3))

(defvar myDifference (- 5 4 3))

(defvar myProduct (* 2 5 6))

(defvar myQuotient (/ 6 3 2 2))

(defvar myRemainder (% 10 6))

(defvar myPower (^ 2 8))

(defvar _myNum 6)
(defvar myInc ++_myNum)

(defvar myMin (min 9 3 7 1))
(defvar myMax (max 9 3 7 1))

(defvar myComp1 (< 1 2 3 4))
(defvar myComp2 (< 1 1 3 4))
(defvar myComp3 (<= 1 2 3 4))
(defvar myComp4 (<= 1 1 3 4))
(defvar myComp5 (> 4 3 2 1))
(defvar myComp6 (> 4 4 2 1))
(defvar myComp7 (>= 4 3 2 1))
(defvar myComp8 (>= 4 4 2 1))
(defvar myComp9 (= 1 1 1 1))
(defvar myComp10 (= 1 2 1 1))

(defvar myIf1 (if 1 true false))
(defvar myIf2 (if 0 true false))
(defvar myIf3 (if -1 true false))
(defvar myIf4 (if null true false))
(defvar myIf5 (if true true false))
(defvar myIf6 (if false true false))
(defvar myIf7 (if "string" true false))
(defvar myIf8 (if "" true false))

(defvar :Int myInt 8)

(defmacrofun doTwiceInt [intOp]
    ,intOp
    ,intOp)

// I think this causes doTwiceInt's runtime function to be typed as requiring Quote<Int> and returning Int
(defun :Int incrementTwice [:Int val]
    (doTwiceInt ++val))

(defmacrofun doTwiceString [stringOp]
    ,stringOp
    ,stringOp)

(defun myTryCatch [:Any e]
    (try
        (throw e)
        (catch [:String error] 5)
        (catch [:Int error] 6)
        (catch [error] 7)))

(defun myTypeCheck []
    (the Int 5))

(defun myGroups1 []
    (Prelude.groups [1 2 3 4] 2))

(defun myGroups2 []
    (Prelude.groups [1 2 3 4] 3 true))

(defun _testLet []
    (let [a 5
            b 6
            :String c "stuff"]
        (Assert.equals 5 a)
        (Assert.equals 6 b)
        (Assert.equals "stuff" c)))

(defvar myConstructedString (new String "sup"))