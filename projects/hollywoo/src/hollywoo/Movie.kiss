// This file is designed to be loaded again by subclasses, with macroVar "subclass" set
(#unless subclass

    // Mostly immutable, reusable resources:
    (prop :Map<String,Set> sets (new Map))
    (prop :Map<String,Actor> actors (new Map))
    (prop :Map<String,Sound> sounds (new Map))
    (prop :Map<String,Song> songs (new Map))
    (prop :Map<String,Prop> props (new Map))

    (prop &mut :DelayHandling delayHandling AutoWithSkip)

    // TODO for some reason this won't work when declared in Kiss syntax:
    // Mutable representation of frames in time:
    // var scenes:Map<String, Scene<Set, StagePosition, StageFacing, ScreenPosition, Actor>> = [];
    (prop :Map<String,Bool> shownScenes (new Map))
    (prop :Map<String,Bool> shownCharacters (new Map))

    // This is set and unset by doPreload defined in HollywooDSL.kiss
    (prop &mut isLoading false)

    (function :Appearance appearanceFlag [:Map<String,Bool> map :String key]
        (if (dictGet map key)
                ReAppearance
            {
                (dictSet map key true)
                FirstAppearance
            }))

    (prop &mut :String sceneKey "")
    (method _currentScene [] (dictGet scenes sceneKey))

    (defNew
        [
            // "View" in the Model-View-Controller architecture:
            &prop :Director<Set,StagePosition,StageFacing,ScreenPosition,Actor,Sound,Song,Prop> director
        ]

        (set director.movie this)

        (super)))

// Some real magic happens here. This macro defines a method, AND a reader macro
// for calling it with cc passed automatically if cc is an argument.

(defMacro hollywooMethod [nameAndType argList &builder b &body body]
    (let [args (expList argList)
            numArgs args.length
            methodName (symbolNameValue nameAndType true)
            readerMacroStart "$(.toUpperCase methodName) "]
        `{
            (defReaderMacro ,readerMacroStart [stream &builder b]
                (b.callSymbol
                    ,methodName
                    ,(for arg args
                        (exprCase arg
                            ((exprTyped Continuation cc)
                                (b.callSymbol "b.symbol" [(b.str "cc")]))
                            (_
                                (b.callSymbol "read" [(b.symbol "stream")]))))))
            (#unless subclass (method ,nameAndType ,argList ,@body))
        }))

(hollywooMethod :Void delay [sec :Continuation cc]
    (case delayHandling
        (Auto
            (Timer.delay cc (* 1000 sec)))
        (AutoWithSkip
            (let [autoDelay
                        (Timer.delay
                            ->{
                                (director.stopWaitForInput)
                                (cc)
                            }
                            (* 1000 sec))]
                (director.startWaitForInput 
                    ->{
                        (director.stopWaitForInput)
                        (autoDelay.stop)
                        (cc)
                    })))
        (Manual
            (director.startWaitForInput
                ->{
                    (director.stopWaitForInput)
                    (cc)
                }))))

(hollywooMethod newSet [name :Set set]
    (assert isLoading)
    (dictSet sets name set))

(hollywooMethod newSceneFromSet [name :String setKey :SceneTime time :ScenePerspective perspective]
    (assert isLoading)
    (dictSet scenes name (objectWith
                                [
                                    set
                                        (dictGet sets setKey)
                                    characters
                                        (new Map)
                                    propsOnScreen
                                        (new Map)
                                ]
                                time
                                perspective)))

(hollywooMethod newScene [name :Scene<Set,StagePosition,StageFacing,ScreenPosition,Actor,Prop> scene]
    (assert isLoading)
    (dictSet scenes name scene))

(hollywooMethod setScene [name :Continuation cc]
    (set sceneKey name)
    (director.showScene
        (dictGet scenes name)
        (appearanceFlag shownScenes name)
        cc))

(hollywooMethod newSound [name :Sound s]
    (assert isLoading)
    (dictSet sounds name s))

(hollywooMethod playSound [name :Continuation cc &opt :Float volumeMod :Bool waitForEnd]
    (set volumeMod (or volumeMod 1))
    (assert (<= 0 volumeMod 1))
    (director.playSound (dictGet sounds name) volumeMod ?waitForEnd cc))

(hollywooMethod awaitPlaySound [name :Continuation cc &opt :Float volumeMod]
    (playSound name cc volumeMod true))

(hollywooMethod newSong [name :Song song]
    (assert isLoading)
    (dictSet songs name song))

(hollywooMethod playSong [name :Continuation cc &opt :Float volumeMod :Bool loop :Bool waitForEnd]
    (set volumeMod (or volumeMod 1))
    (assert (<= 0 volumeMod 1))
    (director.playSong (dictGet songs name) volumeMod ?loop ?waitForEnd cc))

(hollywooMethod awaitPlaySong [name :Continuation cc &opt :Float volumeMod]
    (playSong name cc volumeMod false true))
    
(hollywooMethod loopSong [name :Continuation cc &opt :Float volumeMod]
    (playSong name cc volumeMod true false))

(hollywooMethod stopSong []
    (director.stopSong))

(hollywooMethod newActor [name :Actor actor]
    (assert isLoading)
    (dictSet actors name actor))

(hollywooMethod addCharacter [actorName :StagePosition position :StageFacing facing :Continuation cc]
    (let [character (object stagePosition position stageFacing facing actor (dictGet actors actorName))]
        (dictSet .characters (_currentScene) actorName character)
        (director.showCharacter
            character
            (appearanceFlag shownCharacters actorName)
            cc)
        ))

(hollywooMethod removeCharacter [actorName :Continuation cc]
    (let [c (dictGet .characters (_currentScene) actorName)]
        (.remove .characters (_currentScene) actorName)
        (director.hideCharacter c cc)))

// TODO moveCharacter remove them, add them to another scene
// TODO moveCharacterAndFollow remove them, add them to another scene, set that the scene

(hollywooMethod newProp [name :Prop prop]
    (assert isLoading)
    (dictSet props name prop))

(hollywooMethod addPropToScreen [name :ScreenPosition position :Continuation cc]
    (dictSet .propsOnScreen (_currentScene) name (dictGet props name))
    (director.showPropOnScreen (dictGet props name) position cc))

(hollywooMethod removeProp [name :Continuation cc]
    (director.hideProp (dictGet props name) cc))

// TODO removeProp

// Dialogue:

(hollywooMethod superText [text cc]
    (director.showDialog "" Super "" text cc))

(hollywooMethod normalSpeech [actorName wryly text cc]
    (director.showDialog actorName (OnScreen (dictGet .characters (_currentScene) actorName)) wryly text cc))

(hollywooMethod onPhoneSpeech [actorName wryly text cc]
    (director.showDialog actorName (ifLet [charOnScreen (dictGet .characters (_currentScene) actorName)]
                                    (OnScreen charOnScreen)
                                (FromPhone (dictGet actors actorName))) wryly text cc))