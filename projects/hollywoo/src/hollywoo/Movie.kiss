// This file is designed to be loaded again by subclasses, with macroVar "subclass" set
(#unless subclass

    // Mostly immutable, reusable resources:
    (prop :FuzzyMap<Set> sets (new FuzzyMap<Set>))
    (prop :FuzzyMap<Actor> actors (new FuzzyMap<Actor>))
    (prop :FuzzyMap<Sound> sounds (new FuzzyMap<Sound>))
    (prop :FuzzyMap<Song> songs (new FuzzyMap<Song>))
    (prop :FuzzyMap<Prop> props (new FuzzyMap<Prop>))
    (prop :Map<String,VoiceTrack> voiceTracks (new Map))
    (prop :FuzzyMap<VoiceLine> voiceLines (new FuzzyMap<VoiceLine>))
    // Used to give unique, persistent IDs to voice tracks
    (prop :Map<String,Int> voiceTracksPerActor (new Map))

    (prop &mut :DelayHandling delayHandling AutoWithSkip)

    // TODO for some reason this won't work when declared in Kiss syntax:
    // Mutable representation of frames in time:
    // var scenes:Map<String, Scene<Set, StagePosition, StageFacing, ScreenPosition, Actor>> = [];

    (prop :FuzzyMap<Bool> shownScenes (new FuzzyMap<Bool>))
    (prop :FuzzyMap<Bool> shownCharacters (new FuzzyMap<Bool>))

    // This is set and unset by doPreload defined in HollywooDSL.kiss
    (prop &mut isLoading false)

    (function :Appearance appearanceFlag [:Map<String,Bool> map :String key]
        (if (dictGet map key)
                ReAppearance
            {
                (dictSet map key true)
                FirstAppearance
            }))

    (prop &mut :String sceneKey "")
    (method _currentScene [] (dictGet scenes sceneKey))

    (prop &mut :Map<String,String> intercutMap)
    (method :Void showDialog [actorName dialogType wryly text cc]
        (when intercutMap
            (whenLet [sceneForActor (dictGet intercutMap actorName)]
                (setScene sceneForActor ->{})))
        
        (let [cc ->:Void {(director.hideDialog) (cc)}]
            (director.showDialog actorName dialogType wryly text cc)
            (when (< 0 (count voiceTracks))
                    (case (try (dictGet voiceLines "$actorName $text") (catch [e] (print e) null))
                        ((objectWith trackKey start end)
                            (director.playVoiceTrack (dictGet voiceTracks trackKey) 1 start end cc))
                        (otherwise)))))

    (method newVoiceTrack [actorName :VoiceTrack track :String lineJson]
        (let [actorNumVoiceTracks (or (dictGet voiceTracksPerActor actorName) 0)
                trackKey "${actorName}${actorNumVoiceTracks}"
                :haxe.DynamicAccess<Dynamic> lines (Json.parse lineJson)]
            (dictSet voiceTracksPerActor actorName (+ 1 actorNumVoiceTracks))
            (dictSet voiceTracks trackKey track)
            (doFor =>key line (lines.keyValueIterator)
                (dictSet voiceLines "$actorName $key" (objectWith [start line.start end line.end] trackKey)))))

    (defNew
        [
            // "View" in the Model-View-Controller architecture:
            &prop :Director<Set,StagePosition,StageFacing,ScreenPosition,Actor,Sound,Song,Prop,VoiceTrack> director
            &opt :String voiceLinesJson
        ]

        (set director.movie this)
        (voiceLines.serializeMatches "matchedVoiceLines.json")
        (when voiceLinesJson
            (voiceLines.loadMatches voiceLinesJson))

        (super)))

// Some real magic happens here. This macro defines a method, AND a reader macro
// for calling it with cc passed automatically if cc is an argument.

(defMacro hollywooMethod [nameAndType canSkip argList &builder b &body body]
    (let [args (expList argList)
            numArgs args.length
            methodName (symbolNameValue nameAndType true)
            readerMacroStart "$(.toUpperCase methodName) "]
        `{
            (defReaderMacro ,readerMacroStart [stream &builder b]
                (let [nextLineStream
                            (Stream.fromString (stream.expect "hollywoo macro line" ->(stream.takeLine)))
                        methodCall
                            (b.callSymbol
                                ,methodName
                                ,(for arg args
                                    (exprCase arg
                                        ((exprTyped Continuation cc)
                                            (b.callSymbol "b.symbol" [(b.str "cc")]))
                                        (_
                                            (b.callSymbol "try" [
                                                (b.callSymbol "read" [(b.symbol "nextLineStream")])
                                                // optional arguments may not be present:
                                                (b.callSymbol "catch" [(b.list [(b.symbol "e")]) (b.callSymbol "b.symbol" [(b.str "null")])])
                                            ])))))]
                    (if ,canSkip methodCall (b.callSymbol "noSkip" [methodCall]))))
            (#unless subclass (method ,nameAndType ,argList ,@body))
        }))

(hollywooMethod :Void delay true [sec :Continuation cc]
    (case delayHandling
        (Auto
            (Timer.delay cc (* 1000 sec)))
        (AutoWithSkip
            (let [autoDelay
                        (Timer.delay
                            ->{
                                (director.stopWaitForInput)
                                (cc)
                            }
                            (* 1000 sec))]
                (director.startWaitForInput 
                    ->{
                        (director.stopWaitForInput)
                        (autoDelay.stop)
                        (cc)
                    })))
        (Manual
            (director.startWaitForInput
                ->{
                    (director.stopWaitForInput)
                    (cc)
                }))
        (otherwise (throw "Unsupported delay type $delayHandling"))))

(hollywooMethod newSet true [name :Set set]
    (assert isLoading)
    (dictSet sets name set))

(hollywooMethod newSceneFromSet true [name :String setKey :SceneTime time :ScenePerspective perspective]
    (assert isLoading)
    (dictSet scenes name (objectWith
                                [
                                    set
                                        (dictGet sets setKey)
                                    characters
                                        (new Map)
                                    propsOnScreen
                                        (new Map)
                                ]
                                time
                                perspective)))

(hollywooMethod newScene true [name :Scene<Set,StagePosition,StageFacing,ScreenPosition,Actor,Prop> scene]
    (assert isLoading)
    (dictSet scenes name scene))

(hollywooMethod setScene false [name :Continuation cc]
    (set sceneKey name)
    (director.showScene
        (dictGet scenes name)
        (appearanceFlag shownScenes name)
        cc))

(hollywooMethod newSound true [name :Sound s]
    (assert isLoading)
    (dictSet sounds name s))

(hollywooMethod playSound true [name :Continuation cc &opt :Float volumeMod :Bool waitForEnd]
    (set volumeMod (or volumeMod 1))
    (assert (<= 0 volumeMod 1))
    (director.playSound (dictGet sounds name) volumeMod ?waitForEnd cc))

(hollywooMethod awaitPlaySound true [name :Continuation cc &opt :Float volumeMod]
    (playSound name cc volumeMod true))

(hollywooMethod newSong true [name :Song song]
    (assert isLoading)
    (dictSet songs name song))

(hollywooMethod playSong true [name :Continuation cc &opt :Float volumeMod :Bool loop :Bool waitForEnd]
    (set volumeMod (or volumeMod 1))
    (assert (<= 0 volumeMod 1))
    (director.playSong (dictGet songs name) volumeMod ?loop ?waitForEnd cc))

(hollywooMethod awaitPlaySong true [name :Continuation cc &opt :Float volumeMod]
    (playSong name cc volumeMod false true))
    
(hollywooMethod loopSong true [name :Continuation cc &opt :Float volumeMod]
    (playSong name cc volumeMod true false))

(hollywooMethod stopSong true [cc]
    (director.stopSong)
    (cc))

(hollywooMethod newActor true [name :Actor actor]
    (assert isLoading)
    (dictSet actors name actor))

(hollywooMethod addCharacter false [actorName :StagePosition position :StageFacing facing :Continuation cc]
    (let [character (object stagePosition position stageFacing facing actor (dictGet actors actorName))]
        (dictSet .characters (_currentScene) actorName character)
        (director.showCharacter
            character
            (appearanceFlag shownCharacters actorName)
            cc)))

(hollywooMethod removeCharacter false [actorName :Continuation cc]
    (let [c (dictGet .characters (_currentScene) actorName)]
        (.remove .characters (_currentScene) actorName)
        (director.hideCharacter c cc)))

// TODO moveCharacter remove them, add them to another scene
// TODO moveCharacterAndFollow remove them, add them to another scene, set that the scene

(hollywooMethod newProp true [name :Prop prop]
    (assert isLoading)
    (dictSet props name prop))

(hollywooMethod addPropToScreen false [name :ScreenPosition position :Continuation cc]
    (dictSet .propsOnScreen (_currentScene) name (dictGet props name))
    (director.showPropOnScreen (dictGet props name) position cc))

(hollywooMethod removeProp false [name :Continuation cc]
    (director.hideProp (dictGet props name) cc))

// Dialogue:

(hollywooMethod intercut false [:Map<String,String> actorNamesToSceneNames :Continuation cc]
    (set intercutMap actorNamesToSceneNames)
    (cc))

(hollywooMethod endIntercut false [:Continuation cc]
    (set intercutMap null)
    (cc))

(hollywooMethod superText true [text :Continuation cc]
    (showDialog "" Super "" text cc))

(hollywooMethod normalSpeech true [actorName wryly text :Continuation cc]
    (showDialog actorName (OnScreen (dictGet .characters (_currentScene) actorName)) wryly text cc))

(hollywooMethod voiceOver true [actorName wryly text :Continuation cc]
    (showDialog actorName (VoiceOver (dictGet actors actorName)) wryly text cc))

(hollywooMethod onPhoneSpeech true [actorName wryly text :Continuation cc]
    (showDialog actorName (ifLet [charOnScreen (dictGet .characters (_currentScene) actorName)]
                                    (OnScreen charOnScreen)
                                (FromPhone (dictGet actors actorName))) wryly text cc))