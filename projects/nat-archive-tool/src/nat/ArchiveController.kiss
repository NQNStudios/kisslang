(load "Lib.kiss")

(method :Void _collectAndValidateArg [:CommandArg arg :Dynamic->Void continuation]
    (case arg.type
        (SelectedEntry
            (if (= 1 selectedEntries.length)
                    (continuation (first selectedEntries))
                (ui.reportError "The requested command expects 1 entry to be selected. You have selected: $selectedEntries.length")))
        ((SelectedEntries min max)
            (unless min (set min 0))
            // TODO might want to optimize this O(n) count operation by pre-calculating it 
            (unless max (set max (count archive.entries)))
            (if !(<= min selectedEntries.length max)
                    (ui.reportError "The requested command expects between $min and $max entries to be selected. You have selected: $selectedEntries.length")
                (continuation selectedEntries)))
        ((Text maxLength)
            (unless maxLength (set maxLength Math.POSITIVE_INFINITY))
            (ui.enterText
                "${arg.name} (up to ${maxLength} characters):"
                (lambda :Void [text]
                    (if !(<= text.length maxLength)
                            (ui.reportError "The requested command expected a string up to $maxLength characters long. You entered: $text.length characters")
                        (continuation text)))
                maxLength))
        ((VarText maxLength)
            (unless maxLength (set maxLength Math.POSITIVE_INFINITY))
            (let [collectedText
                        []
                    &mut :Void->Void enterTextAgain
                        null
                    _enterTextAgain
                        ->:Void
                            (ui.enterText
                                "${arg.name} (up to ${maxLength} characters):"
                                (lambda :Void [text]
                                    (if !text
                                            (continuation collectedText)
                                        (if !(<= text.length maxLength)
                                                (ui.reportError "The requested command expected a list of strings up to $maxLength characters long. You entered: $text.length characters")
                                            {(collectedText.push text)
                                                (enterTextAgain)})))
                                maxLength)]
                (set enterTextAgain _enterTextAgain)
                (enterTextAgain)))
        ((Number min max inStepsOf)
            (unless min (set min Math.NEGATIVE_INFINITY))
            (unless max (set max Math.POSITIVE_INFINITY))
            (let [&mut prompt "${arg.name} (${min}-${max}"]
                (when inStepsOf
                    (+= prompt " in steps of ${inStepsOf}"))
                (+= prompt "):")

                (ui.enterNumber
                    prompt
                    (lambda :Void [number]
                        (let [minMaxError
                                    "The requested command expected a number between $min and $max"
                                stepError
                                    "$minMaxError in steps of $inStepsOf"
                                youEntered
                                    ". You entered: $number"]
                            (if (or
                                        !(<= min number max)
                                        (and inStepsOf !(= 0 (% (- number min) inStepsOf))))
                                    (if inStepsOf
                                            (ui.reportError "${stepError}$youEntered")
                                        (ui.reportError "${minMaxError}$youEntered"))
                                (continuation number))))
                    min
                    max
                    inStepsOf)))
        (OneEntry
            (ui.chooseEntry
                "${arg.name}:"
                archive
                continuation))
        ((Entries min max)
            (unless min (set min 1))
            // TODO might want to optimize this O(n) count operation by pre-calculating it 
            (unless max (set max (count archive.entries)))
            (ui.chooseEntries
                "${arg.name}:"
                archive
                (lambda :Void [:Array<Entry> entries]
                    (if (or
                                (> min entries.length)
                                (< max entries.length))

                            (ui.reportError "The requested command expects between $min and $max entries. You chose: $entries.length")
                    (continuation entries)))
                min
                max))))

(method :Void->Void _composeArgCollector [:Array<Dynamic> collectedArgs :CommandArg arg :Void->Void lastCollector]
    (lambda :Void []
        (_collectAndValidateArg arg ->:Void [:Dynamic argValue] {(collectedArgs.push argValue) (lastCollector)})))

(method :Void tryRunCommand [:String commandName]
    (let [lowerCommandName (commandName.toLowerCase)]
        (if (commands.exists lowerCommandName)
                (_runCommand (dictGet commands lowerCommandName))
            (ui.displayMessage "$commandName is not a valid command"))))

(method :Void _runCommand [:Command command]
    (let [collectedArgs
                []
            &mut lastCollector
                (lambda []
                    (set lastChangeSet (the ChangeSet (Reflect.callMethod null command.handler collectedArgs)))
                    (ui.handleChanges archive lastChangeSet))]
        // To facilitate asynchronous arg input via UI, we need to construct an insanely complicated nested callback to give the UI
        (doFor arg (reversed command.args)
            (set lastCollector (_composeArgCollector collectedArgs arg lastCollector)))
        (lastCollector)))

(defMacro defCommand [name args &body body]
    (let [argPairs
                (groups (expList args) 2)
            methodArgs
                (for [name type] argPairs
                    // TODO write an exprCase macro that simplifies this terrible mess,
                    // and maybe adds back precise pattern matching instead of relying
                    // on partial string matching
                    (exprCase type
                        ((exprOr SelectedEntry OneEntry) `:nat.Entry ,name)
                        ((exprOr (SelectedEntries _ _) (Entries _ _)) `:Array<nat.Entry> ,name)
                        ((Text _) `:String ,name)
                        ((VarText _) `:Array<String> ,name)
                        ((Number _ _ _) `:Float ,name)))
            commandArgs
                (for [name type] argPairs
                    `(object name ,(symbolName name) type ,type))]
        `{
            (method ,name [,@methodArgs] ,@body)
            // Preserve the capitalization of the command name for pretty help message
            (commandNames.push ,(symbolName name))
            // Store the command name without capitalization for forgiving call conventions
            (dictSet commands ,(ReaderExp.StrExp (.toLowerCase (symbolNameValue name))) (object args [,@commandArgs] handler (the Function ,name)))}))

(var :Array<String> commandNames [])


(defNew [&prop :Archive archive
            &prop :ArchiveUI ui]
    [&mut :Array<Entry> selectedEntries []
        &mut :ChangeSet lastChangeSet []
        :Map<String,Command> commands (new Map)
        :NameSystem nameSystem (new NameSystem)]

    (ui.setController this)

    // Add systems!
    (archive.addSystem nameSystem)
    (archive.addSystem (new WikipediaImageSystem))
    // Just for testing:
    (archive.addSystem (new AttachmentSystem ["jpg" "jpeg" "png"] ->[archive e files] ~files))

    (archive.processSystems)
    
    (defCommand Help []
        (ui.displayMessage
            (+ "Available commands:\n"
                (commandNames.join "\n"))) [])

    (defCommand SelectEntry [e OneEntry]
        (set selectedEntries [e]) [])

    (defCommand SelectEntries [entries (Entries null null)]
        (set selectedEntries entries) [])

    (defCommand SelectAllEntries []
        (set selectedEntries (for =>id e archive.entries e)) [])

    (defCommand SelectLastChangeSet []
        (set selectedEntries lastChangeSet) [])

    (defCommand PrintSelectedEntries [entries (SelectedEntries null null)]
        (doFor e entries (ui.displayMessage (archive.fullString e))) [])
    
    (defCommand PrintComponent [entries (SelectedEntries null null)
                                    componentType (Text null)]
        (doFor e entries (ui.displayMessage (archive.componentData e componentType))) [])
        
    (defCommand CreateEntry [name (Text null)]
        [(archive.createEntry ->e
            (addComponent archive e Name name))])
    
    (defCommand CreateEntries [names (VarText null)]
        // createEntry returns a list, so these lists must be flattened
        (flatten (for name names
            (CreateEntry name))))
            
    (defCommand AddTags [entries (SelectedEntries 1 null)
                            tagsToAdd (VarText null)]
        (doFor e entries
            (addTags archive e tagsToAdd))
        entries) // TODO this includes entries that already had the tag in the changeset

    (defCommand RemoveTags [entries (SelectedEntries 1 null)
                                tagsToRemove (VarText null)]
        (doFor e entries
            (removeTags archive e tagsToRemove))
        entries) // TODO this includes entries that didn't have the tag in the changeset
        
    (defCommand SelectByTags [tagsBoolExp (Text null)]
        (SelectEntries (filter archive.entries ->e (tagsMatch archive e tagsBoolExp))))
        
    (defCommand SelectByComponents [componentsBoolExp (Text null)]
        (SelectEntries (filter archive.entries ->e (componentsMatch e componentsBoolExp))))
        
    (defCommand AddFiles [entries (SelectedEntries 1 null)
        // TODO add File and Files as an argument type for commands, ArchiveUI
        // TODO make tkinter file browser externs and use tkinter as the file picking mechanism for CLI
                                files (VarText null)]
        (doFor e entries
            (addFiles archive e files))
        entries)
    
    (defCommand SelectByName [name (Text null)]
        (SelectEntries (nameSystem.getEntries name)) []))
