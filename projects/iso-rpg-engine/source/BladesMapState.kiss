// TODO make these variables
(var FLOOR_WIDTH 46)
(var FLOOR_HEIGHT 32)
(var SPRITE_HEIGHT 55)
(prop :Array<FlxSprite> floorTiles [])
(prop &mut :ScenData data null)

(method &override :Void create []
    (super.create)
    (set data (ScenData.coreData))

    (Scenario.test)

    (let [valleydy (Scenario.fromBasFile "Blades of Avernum Scenarios/Valley of Dying Things/valleydy.bas")]
        (addSprites 
            // 2D nth >:)
            (nth valleydy.outdoorSections 0 0))))

(var SELECTED_COLOR FlxColor.LIME)
(var NORMAL_COLOR FlxColor.WHITE)
(var CLIFF_HEIGHT 22)

(method :Void addSprites [:TileMap map]
    (let [&mut rowStartX 0
            &mut rowStartY 0]
        (doFor tileY (range map.height)
            (let [&mut x rowStartX
                    &mut y rowStartY]
                (doFor tileX (range map.width)
                    (let [height (nth map.floorHeights tileX tileY)
                            floor (nth map.floorCodes tileX tileY)
                            terrain (nth map.terrainCodes tileX tileY)
                            yOffset (* CLIFF_HEIGHT height)]
                        // First add the floor
                        (let [tileSprite (data.floorSprite floor)]
                            // TODO add cliffs if it's higher than the one in front of it
                            (set tileSprite.x x)
                            (set tileSprite.y (- y yOffset))
                            (FlxMouseEventManager.add tileSprite
                                // handle click on floor:
                                ->downTS {}
                                ->upTS {}
                                ->overTS (set overTS.color SELECTED_COLOR)
                                ->outTS (set outTS.color NORMAL_COLOR))
                            (add tileSprite))

                        // TODO add any items

                        // TODO add any characters

                        // TODO the wall sprites will be from different sheets defined by town/outdoor section
                        (let [tileSprite (data.terrainSprite terrain)]
                            (set tileSprite.x x)
                            (set tileSprite.y (- y yOffset))
                            (when (> tileSprite.height SPRITE_HEIGHT)
                                (-= tileSprite.y SPRITE_HEIGHT))
                            (FlxMouseEventManager.add tileSprite
                                // Handle click on terrain:
                                ->downTS {}
                                ->upTS {}
                                ->overTS (set overTS.color SELECTED_COLOR)
                                ->outTS (set outTS.color NORMAL_COLOR))
                            (add tileSprite)))
                    (+= x (/ FLOOR_WIDTH 2))
                    (+= y (/ FLOOR_HEIGHT 2))))
            (-= rowStartX (/ FLOOR_WIDTH 2))
            (+= rowStartY (/ FLOOR_HEIGHT 2)))))

(var CAMERA_SPEED 500)

(method &override :Void update [:Float elapsed]
    (super.update elapsed)
    // scroll to zoom:
    #{
        if (FlxG.mouse.wheel != 0) {
            FlxG.camera.zoom += (FlxG.mouse.wheel / 10);
        }
    }#
    // F1 to toggle fullscreen:
    (when FlxG.keys.justPressed.F1
        (set FlxG.fullscreen !FlxG.fullscreen))

    (let [&mut cameraMovement (new FlxVector 0 0)]
        (when (or (= 0 FlxG.mouse.screenX) FlxG.keys.pressed.LEFT)
            (set cameraMovement.x -1))
        (when (or (= 0 FlxG.mouse.screenY) FlxG.keys.pressed.UP)
            (set cameraMovement.y -1))
        (when (or (= (- FlxG.width 1) FlxG.mouse.screenX) FlxG.keys.pressed.RIGHT) 
            (set cameraMovement.x 1))
        (when (or (= (- FlxG.height 1) FlxG.mouse.screenY) FlxG.keys.pressed.DOWN)
            (set cameraMovement.y 1))
        (set cameraMovement (cameraMovement.truncate 1))
        (set cameraMovement (cameraMovement.scale (* elapsed CAMERA_SPEED)))
        (set FlxG.camera.scroll (FlxG.camera.scroll.add cameraMovement.x cameraMovement.y))))