(import
    datetime.DateTime
    datetime.DateTimeInterval
    kiss_spaced_rep.Card)

(var oneDayInterval (DateTimeInterval.create (DateTime.make 1970 1 1) (DateTime.make 1970 1 2)))
(var halfDayInterval (DateTimeInterval.create (DateTime.make 1970 1 1 0) (DateTime.make 1970 1 1 12)))
(var studyList [])

(function :Void basicShow [text :Void->Void cc]
    (Sys.print text)
    (.readLine (Sys.stdin))
    (cc))

(function basicScore [text :Int->Void resolve]
    (Sys.println text)
    (Sys.print "Score (0-5): ")
    (resolve (Std.parseInt (.readLine (Sys.stdin)))))

(function :CardSide basicText [:String text]
    (object
        show (basicShow.bind text)
        score (basicScore.bind text)))

(defMacroVar cardId 0)

(defMacro card [front back &builder b]
    (let [cObject (b.symbol "cObject$cardId")
            cScore (b.symbol "cScore$cardId")
            cRepetitions (b.symbol "cRepetitions$cardId")
            cPreviousEaseFactor (b.symbol "cPreviousEaseFactor$cardId")
            cPreviousInterval (b.symbol "cPreviousInterval$cardId")
            cNextDate (b.symbol "cNextDate$cardId")
            cStudy (b.symbol "cStudy$cardId")]
        (setMacroVar cardId (+ cardId 1))
        `{
            (var ,cObject (object front ,front back ,back))
            (savedVar :Int ,cRepetitions 0)
            (savedVar :Float ,cPreviousEaseFactor 2.5)
            (savedVar :Int ,cPreviousInterval 0)
            (savedVar :Float ,cNextDate (DateTime.make))

            (let [:DateTime nextDate ,cNextDate]
                (localFunction :Void ,cStudy [:Void->Void cc]
                    (localFunction :Void ,cScore [:Int quality]
                        (localVar &mut interval 0)
                        (cond 
                            ((>= quality 3)
                                (set interval (Math.ceil (case ,cRepetitions (0 1) (1 6) (more (* ,cPreviousEaseFactor ,cPreviousInterval)) (never otherwise))))
                                (+= ,cRepetitions 1)
                                (set ,cPreviousEaseFactor (+ ,cPreviousEaseFactor (- 0.1 (* (- 5 quality) (+ 0.08 (* (- 5 quality ) 0.02)))))))
                            (true
                                (set ,cRepetitions 0)
                                (set interval 1)))
                        (set ,cPreviousEaseFactor (max 1.3 ,cPreviousEaseFactor))
                        (set ,cPreviousInterval interval)
                        (let [:DateTime cNextDate (DateTime.now)]
                            #{cNextDate += halfDayInterval;}#
                            (doFor _ (range (- interval 1))
                                #{cNextDate += oneDayInterval;}#)
                            (set ,cNextDate cNextDate))
                        (cc))

                    (if (or #{DateTime.now() > nextDate;}# (#if debug true false))
                            (.show .front ,cObject
                                ->:Void 
                                    (.score .back ,cObject ,cScore))
                        {
                            (print "skipping a card until $(nextDate.toString)")
                            (cc)
                        }))
                (studyList.push ,cStudy))
        }))


(function :Void studyAll []
    (when studyList
        (let [nextIndex (Std.random studyList.length)
                nextToStudy (nth studyList nextIndex)]
            (studyList.splice nextIndex 1)
            (nextToStudy studyAll))))

// TODO make a note macro that defines a card then defines it in reverse
// TODO make a cloze macro that makes a card with each group deleted