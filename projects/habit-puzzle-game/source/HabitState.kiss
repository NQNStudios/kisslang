(method &override :Void create [] (super.create))
(method &override :Void update [:Float elapsed]
    (super.update elapsed)
    // Hold left-click to hide the habit text and see the image clearly:
    (when entryTexts (if FlxG.mouse.pressed (remove entryTexts) (add entryTexts)))
    // Handle keyboard input:
    (when shortcutHandler
        (shortcutHandler.update)))

(prop &mut :FlxTypedGroup<FlxText> entryTexts null)
(prop &mut :FlxTypedGroup<FlxSprite> rewardBlockers null)
(prop &mut :FlxKeyShortcutHandler<Entry> shortcutHandler null)

(prop &mut :HabitModel model null)

(var PUZZLE_WIDTH 4)
(var PUZZLE_HEIGHT 4)
(var TOTAL_PIECES (* PUZZLE_WIDTH PUZZLE_HEIGHT))
(prop &mut :FlxSprite rewardSprite null)

(method setModel [m]
    (set model m)
    (set shortcutHandler (new FlxKeyShortcutHandler))

    (let [p (m.totalPoints)
            &mut i 0
            &mut currentRewardFile null]
        // Find, load, and add the current reward image as big as possible:
        (while (> p .startingPoints (nth m.rewardFiles i))
            (set currentRewardFile (nth m.rewardFiles i))
            (if (>= ++i m.rewardFiles.length)
                    (break)))
        (when rewardSprite
            (remove rewardSprite))
        (set rewardSprite (new FlxSprite 0 0 (BitmapData.fromFile (joinPath (Path.directory m.textFile) currentRewardFile.path))))
        (rewardSprite.setGraphicSize FlxG.width 0)
        (rewardSprite.updateHitbox)
        (when (> rewardSprite.height FlxG.height)
            (rewardSprite.setGraphicSize 0 FlxG.height))
        (rewardSprite.updateHitbox)
        (rewardSprite.screenCenter)
        (add rewardSprite)

        (when rewardBlockers
            (remove rewardBlockers))
        (set rewardBlockers (new FlxTypedGroup))
        (add rewardBlockers)

        (let [PIECE_WIDTH 
                    (/ rewardSprite.width PUZZLE_WIDTH)
                PIECE_HEIGHT
                    (/ rewardSprite.height PUZZLE_HEIGHT)
                :Array<FlxPoint> blockerPoints []]
            (doFor x (range PUZZLE_WIDTH)
                (doFor y (range PUZZLE_HEIGHT)
                    (blockerPoints.push (new FlxPoint (+ rewardSprite.x (* x PIECE_WIDTH)) (+ rewardSprite.y (* y PIECE_HEIGHT))))))
            // Cover it up with (TOTAL_PIECES - p) black squares placed randomly by choosing and removing from a zipped coordinate list
            (let [r (new FlxRandom (Strings.hashCode currentRewardFile.path))]
                (r.shuffle blockerPoints)
                (doFor i (range (- (+ TOTAL_PIECES currentRewardFile.startingPoints) p))
                    (let [pos (nth blockerPoints i)
                            s (new FlxSprite pos.x pos.y)]
                        (s.makeGraphic (Math.ceil PIECE_WIDTH) (Math.ceil PIECE_HEIGHT) FlxColor.BLACK)
                        (rewardBlockers.add s))))))


    (when entryTexts (remove entryTexts))
    (set entryTexts (new FlxTypedGroup))
    (set textY 0)
    (set color FlxColor.ORANGE)
    (map (m.activeDailyEntries) makeText)
    (set color FlxColor.WHITE)
    (map (m.activeBonusEntries) makeText)
    (set color FlxColor.YELLOW)
    (map (m.activeTodoEntries) makeText)
    (add entryTexts)

    (doFor e (the Array<Entry> (concat m.dailyEntries m.bonusEntries m.todoEntries))
        (when (HabitModel.isActive e)
            (let [label (HabitModel.activeLabel e)]
                (shortcutHandler.registerItem label.label e))))

    (set shortcutHandler.onBadKey ->:Void [_ _] {})
    (set shortcutHandler.onSelectItem ->:Void [:Entry e]
        (let [label (HabitModel.activeLabel e)]
            (+= label.points 1)
            (whenLet [(Daily days lastDayDone) e.type]
                (set e.type (Daily days (HabitModel.todayString))))
            (m.save)
            (setModel m)
            (shortcutHandler.start)))
    (shortcutHandler.start))

(prop &mut textY 0)
(prop &mut :FlxColor color null)

(method makeText [:Entry e]
    (let [label (HabitModel.activeLabel e)
            text (new FlxText 0 textY 0 (+ label.label (* label.points "+")))]
        (set text.color color)
        (+= textY text.height)
        (entryTexts.add text)))