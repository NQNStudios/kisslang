(method &override :Void create [] (super.create))
(method &override :Void update [:Float elapsed]
    (super.update elapsed)
    (let [:FlxKey id (FlxG.keys.firstJustPressed)]
        (unless (= id -1)
            (shortcutHandler.handleKey (.toLowerCase (id.toString))))))

(prop &mut :FlxTypedGroup<FlxText> entryTexts null)
(prop &mut :KeyShortcutHandler<Entry> shortcutHandler null)

(prop &mut :HabitModel model null)
(method setModel [m]
    (set model m)
    ~(m.totalPoints)
    (set shortcutHandler (new KeyShortcutHandler))

    (when entryTexts (remove entryTexts))
    (set entryTexts (new FlxTypedGroup))
    (set textY 0)
    (set color FlxColor.ORANGE)
    (map (filter m.dailyEntries HabitModel.isActive) makeText)
    (set color FlxColor.WHITE)
    (map m.bonusEntries makeText)
    (set color FlxColor.YELLOW)
    (map m.todoEntries makeText)
    (add entryTexts)

    (doFor e (the Array<Entry> (concat m.dailyEntries m.bonusEntries m.todoEntries))
        (let [label (HabitModel.activeLabel e)]
            (shortcutHandler.registerItem label.label e)))

    **(set shortcutHandler.onBadKey ->:Void [_ _] {})
    (set shortcutHandler.onSelectItem ->:Void [:Entry e]
        (let [label (HabitModel.activeLabel e)]
            **(TODO reveal a piece of the current puzzle)
            (+= label.points 1)
            (case e.type
                (Todo
                    (m.todoEntries.remove e))
                (Bonus)
                ((Daily _)
                    (set e.doneToday true))
                (otherwise (throw "bad type")))
            (m.save)
            (setModel m)
            (shortcutHandler.start)))
    (shortcutHandler.start))

(prop &mut textY 0)
(prop &mut :FlxColor color null)

(method makeText [:Entry e]
    (let [label (HabitModel.activeLabel e)
            text (new FlxText 0 textY 0 (+ label.label (* label.points "+")))]
        (set text.color color)
        (+= textY text.height)
        (entryTexts.add text)))