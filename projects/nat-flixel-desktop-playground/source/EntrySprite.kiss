(loadFrom "nat-archive-tool" "src/nat/Lib.kiss")

(defNew [&prop :EntrySpriteSystem system
            &prop :String positionKey
            &prop :Position position
            &prop :Archive archive
            &prop :Entry e
            &prop :ArchiveController controller]
    [&mut :Bool selected false]
    (super position.x position.y)
    (if (hasComponent e Images)
            (let [images (readComponent e Images)]
                (.onComplete (BitmapData.loadFromFile (joinPath archive.archiveDir "files" (nth images.imageFiles images.pinnedImageIndex)))
                    ->bitmapData {
                        (loadGraphic bitmapData)
                    }))
            (set pixels .pixels (new FlxText 0 0 0 (readComponent e Name) 16)))
    (updateColor)
    (when (hasComponent e Scale)
        (let [:Float scale (readComponent e Scale)]
            (this.scale.set scale scale)
            (updateHitbox)))
    (enableMouseClicks false)
    (enableMouseDrag)
    (set mouseStartDragCallback
        ->[self _dx _dy]
            (doFor sprite (system.getSelectedSprites)
                (unless (= sprite.e.id this.e.id)
                    (sprite.fixToSprite this))))

    (set mouseStopDragCallback
        ->[self _dx _dy]
            {
                (savePos)
                (doFor sprite (system.getSelectedSprites)
                    (unless (= sprite.e.id this.e.id)
                        (sprite.endFixToSprite)))
            }))

(prop &mut :EntrySprite fixedToSprite)
(prop &mut :FlxPoint fixedOffset)

(method savePos []
    (FlxG.camera.extendScrollBounds this PlayState.SCROLL_BOUND_MARGIN)
    (withWritableComponents archive e [positions Positions]
        (let [pos (dictGet positions positionKey)]    
            (dictSet positions positionKey (object x (cast this.x Float) y (cast this.y Float) z pos.z)))))

(method &override :Void update [:Float elapsed] 
    (super.update elapsed)
    (when fixedToSprite
        (set x (+ fixedToSprite.x fixedOffset.x))
        (set y (+ fixedToSprite.y fixedOffset.y))))

(method fixToSprite [:EntrySprite sprite]
    (set fixedToSprite sprite)
    (set fixedOffset (new FlxPoint (- x sprite.x) (- y sprite.y))))


(method endFixToSprite []
    (savePos)
    (set fixedToSprite null))

(method updateColor []
    (if (controller.isSelected e)
            {
                (set color FlxColor.BLUE)
            }
        {
            (set color FlxColor.WHITE)
        }))