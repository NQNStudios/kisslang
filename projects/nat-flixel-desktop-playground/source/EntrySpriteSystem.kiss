(loadFrom "nat-archive-tool" "src/nat/Lib.kiss")

(prop :Map<String,EntrySprite> sprites (new Map))

// TODO this can also handle text sprites, and instead of saving out the text bitmap,
// just make the FlxText every time at runtime -- so PinNextImage won't be needed
// when the media tag is added

(defNew [&prop :PlayState playState
            &prop :ArchiveController controller]
    (super
        playState
        ->[archive e]
            ?(hasComponent e Name)
        ->[archive e pos &opt ui]
            (unless (sprites.exists e.id)
                (let [sprite (new EntrySprite this _playgroundKey pos archive e controller)]
                    (playState.entryGroup.add sprite)
                    (dictSet sprites e.id sprite))))
    
    (set onRemoveEntry
        ->[archive e &opt ui]
            {
                (.kill (dictGet sprites e.id))
                (sprites.remove e.id)
                // When an Entry is hidden, we can bet the user doesn't want it selected anymore
                (controller.DeSelectEntry e)
            }))

(method &override :Void clear []
    (sprites.clear)
    (playState.entryGroup.kill)
    (playState.entryGroup.clear)
    (playState.entryGroup.revive)
    (controller.SelectEntries []))

(method z [:Entry e]
    .z (dictGet (readComponent e Positions) _playgroundKey))

// override process to z-sort all sprites after making them
(method &override :Void process [:Archive archive &opt :ArchiveUI ui]
    (super.process archive ui)
    (FlxG.camera.calculateScrollBounds playState.entryGroup PlayState.SCROLL_BOUND_MARGIN)
    (playState.entryGroup.sort ->[o s1 s2] (FlxSort.byValues o (z s1.e) (z s2.e))))

(method getSelectedSprites []
    (filter (for e (controller.getSelectedEntries) (dictGet sprites e.id))))

(prop defaultSpacing 100)
(prop &mut defaultX 0)
(method &override :Position defaultPosition [_] 
    (+= defaultX defaultSpacing)
    (object x defaultX y 0.0 z 0.0))