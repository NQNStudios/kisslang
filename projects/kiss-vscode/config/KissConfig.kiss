/**
 * Aliases
 */

// output 
(defalias &call infoMessage Vscode.window.showInformationMessage)
(defalias &call warningMessage Vscode.window.showWarningMessage)
(defalias &call errorMessage Vscode.window.showErrorMessage)

// input
(defalias &call inputBox Vscode.window.showInputBox)
(defalias &call quickPick Vscode.window.showQuickPick)

// ui
(defalias &ident activeTextEditor Vscode.window.activeTextEditor)

/**
 * Helper functions
 */
(defun selectedText []
    (if (and activeTextEditor .selection activeTextEditor)
            (let [document
                        // TODO should be able to use activeTextEditor.document and have the alias still work
                        .document activeTextEditor
                    selection
                        .selection activeTextEditor
                    range (new Range selection.start selection.end)]
                (document.getText range))
        ""))

// TODO make an async annotation that throws an error if the promise is not wrapped in awaitLet or awaitBegin or returned by an async function?
// but in some cases it doesn't matter and there are so many edge cases.
(defun insertAt [:Position pos text]
    (.edit activeTextEditor
        (lambda [e]
            (e.insert pos text))))

(defun insert [text]
    // TODO this let is because identifier alias dot access is broken:
    (let [editor activeTextEditor]
        (insertAt editor.selection.active text)))

/**
 * State
 */

(defvar :Map<String,Command> commands (new Map))
(defvar &mut :String lastCommand null)
(defvar parser (new Parser))
(defvar interp (new Interp))

/**
 * Functionality
 */

(defun :String convertToHScript [kissStr]
    (let [kissProcess (ChildProcess.spawnSync "haxelib" ["run" "kiss" "--all"] (object input kissStr))]
        (if !(= kissProcess.status 0)
                {(errorMessage "failed to compile ${kissStr}: $(.toString (the Buffer .stderr kissProcess))") ""}
            (.toString (the Buffer .stdout kissProcess)))))

(defun :Dynamic evalString [:String kissStr]
    (try
            (interp.execute
                (parser.parseString
                    (convertToHScript kissStr)))
        (catch [e]
            (errorMessage "Error `${e}` from $kissStr")
            null)))

(defun :Void evalAndPrint [&opt :String selectedText]
    (if selectedText
            (infoMessage (Std.string (evalString selectedText))))
        
        (awaitLet [kissStr (inputBox)]
            (infoMessage (Std.string (evalString kissStr)))))

(defun :Void runCommand [&opt command]
    (if command
            {(set lastCommand command) ((dictGet commands command) (selectedText))}
        (let [commandList
                    (for description (commands.keys)
                        (object
                            label description
                            description null
                            detail null
                            picked null
                            alwaysShow null))]
            (awaitLet [chosenCommand (quickPick commandList)]
                (when chosenCommand
                    (set lastCommand chosenCommand.label)
                    ((dictGet commands chosenCommand.label) (selectedText)))))))

(defun :Void runLastCommand [&opt _]
    (if lastCommand
            (runCommand lastCommand)
        (errorMessage "No Kiss command was run previously.")))

(defun :Void runKeyboardShortcut [&opt _]
    // TODO
    (errorMessage "Keyboard shortcut commands are not yet implemented"))

(defun registerCommand [description command]
    (dictSet commands description command))

(defun :Void registerBuiltins []
    (set Prelude.print
        ->[v] {
            (infoMessage (Std.string v))
            v})
    (registerCommand "Rerun last command" runLastCommand)
    (registerCommand "Run a keyboard shortcut command" runKeyboardShortcut)
    (registerCommand "Evaluate and print a Kiss expression" evalAndPrint))

(defun :Void prepareInterp []
    (interp.variables.set "kiss" 
        (object
            Operand
                (object
                    fromDynamic Operand.fromDynamic)
            Prelude
                Prelude))
            //interp.variables.set("Helpers", Helpers);
    (interp.variables.set "Prelude" Prelude)
    (interp.variables.set "Lambda" Lambda)
    // TODO for some reason, (interp.variables.set "Std" Std) doesn't capture
    // some static functions, like parseInt. So this kludgy bit is necessary:
    (interp.variables.set "Std"
        (object
            parseInt Std.parseInt
            string Std.string
            random Std.random
            int Std.int)))
