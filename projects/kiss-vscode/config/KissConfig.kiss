(loadFrom "kiss-vscode" "src/Util.kiss")

// ui
(defAlias &ident activeTextEditor Vscode.window.activeTextEditor)

/**
 * Helper functions
 */
(function selectedText []
    (if (and activeTextEditor activeTextEditor.selection)
            (let [document
                        activeTextEditor.document
                    selection
                        activeTextEditor.selection
                    range (new Range selection.start selection.end)]
                (document.getText range))
        ""))

(function insertAt [:vscode.Position pos text]
    (activeTextEditor.edit
        (lambda [e]
            (e.insert pos text))))

(function insert [text]
    (insertAt activeTextEditor.selection.active text))

/**
 * State
 */

(var :Map<String,Command> commands (new Map))
(var :Map<String,ShortcutKey> commandShortcuts (new Map))

(var &mut :String lastCommand null)
(var parser (new Parser))
(var interp (new Interp))

/**
 * Functionality
 */

// TODO pass macros and aliases from Util.kiss to the KissState of "eval kiss expression"
(function :Dynamic evalString [:String kissStr]
    (try
            (interp.execute
                (parser.parseString
                    (Prelude.convertToHScript kissStr)))
        (catch [e]
            (errorMessage "Error `${e}` from $kissStr")
            null)))

(function :Void runCommand [&opt command] (_runCommand command))

(defMacro _runCommandFunc [commandName]
    `(let [command ,commandName]
        (set lastCommand command)
        (try ((dictGet commands command) inputText)
            (catch [error] (errorMessage "error from ${command}: $error") (return)))))

(function :Void _runCommand [&opt command inputText]
    (unless inputText (set inputText (selectedText)))
    (if command
            (_runCommandFunc command)
            (awaitLet [chosenCommand (quickPick (collect (commands.keys)))]
                (when chosenCommand
                    (_runCommandFunc chosenCommand)))))

(function :Void runLastCommand [&opt _]
    (if lastCommand
            (runCommand lastCommand)
        (errorMessage "No Kiss command was run previously.")))

(var &mut :vscode.WebviewPanel shortcutPanel null)
(var &mut :vscode.TextDocument documentBeforeShortcut null)
(var &mut :String selectedTextBeforeShortcut null)

(function :Void showShortcutPanel [&opt :Map<String,ShortcutKey> prefixMap]
    // Preserve the selected text and focused document before opening the webview:
    (whenLet [text (selectedText)] (set selectedTextBeforeShortcut text))
    (if activeTextEditor
            (set documentBeforeShortcut activeTextEditor.document)
        (unless prefixMap (set documentBeforeShortcut null)))

    // When called without a prefixMap, if a shortcut panel is still open, close it and start over:
    (unless prefixMap 
        (when shortcutPanel
            // TODO for some reason, method calling an object in (when [object] ...) context, resets the object's type to Any unless (the [Type]) is used
            (.dispose (the WebviewPanel shortcutPanel))
            (set shortcutPanel null))
        (set prefixMap commandShortcuts))
    (when shortcutPanel (shortcutPanel.dispose))
    (set shortcutPanel (Vscode.window.createWebviewPanel 
                                            "kissShortcut"
                                            "Kiss Shortcuts"
                                            vscode.ViewColumn.Two
                                            (object
                                                enableScripts true)))
    // The keyListener handler needs to have access to the Disposible object to dispose itself, hence this let/set
    (let [&mut keyListener null]
        (set keyListener (shortcutPanel.webview.onDidReceiveMessage
                                ->:Void key
                                    (case (the String key)
                                        ((when (prefixMap.exists key) key)
                                            (keyListener.dispose)
                                            (case (dictGet prefixMap key)
                                                ((Prefix innerMap)
                                                    (showShortcutPanel innerMap))
                                                ((Final command)
                                                    // TODO dispose() for some reason doesn't take effect until
                                                    // the awaitLet below finishes its work...
                                                    (shortcutPanel.dispose)
                                                    (if documentBeforeShortcut
                                                            (awaitLet [_ (Vscode.window.showTextDocument documentBeforeShortcut)]
                                                                (_runCommand command selectedTextBeforeShortcut))
                                                        (_runCommand command selectedTextBeforeShortcut)))))

                                    ("Escape"
                                        (shortcutPanel.dispose))    

                                    (otherwise (warningMessage "$key is not mapped to a shortcut in this context"))))))
    (set shortcutPanel.webview.html (shortcutPanelHtml prefixMap))
    (shortcutPanel.webview.postMessage (object command "focus")))

(function shortcutPanelHtml [:Map<String,ShortcutKey> prefixMap]
    (let [shortcutParagraphs
                (for =>key shortcutKey prefixMap
                    "<p><strong>${key}</strong> - $(case shortcutKey
                                    ((Prefix innerMap)
                                        "$(Lambda.count innerMap) shortcuts")
                                    ((Final command)
                                        command))</p>")]
        "<!DOCTYPE html>
        <html lang=\"en\">
            <head>
                <meta charset=\"UTF-8\">
                <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">
                <title>Kiss Shortcuts</title>
            </head>
            <body>
                $(shortcutParagraphs.join "")
                <script>
                    const vscode = acquireVsCodeApi();
                    window.addEventListener('message', function(event) {
                        var message = event.data;

                        switch (message.command) {
                            case 'focus':
                                window.focus();
                                break;
                        }
                    });
                    window.addEventListener('keydown', function (e) {
                        vscode.postMessage(e.key);
                    });
                </script>
            </body>
        </html>"))

(function :Void runKeyboardShortcut [&opt _]
    (showShortcutPanel))

// Extract [k]eyboard [s]hortcuts from a string:
(function extractKeyboardShortcuts [str &opt :Stream stream :String shortcuts]
    (unless stream (set stream (Stream.fromString str)))
    (unless shortcuts (set shortcuts ""))
    (case (stream.takeUntilAndDrop "[")
        ((Some _)
            (case (stream.takeUntilAndDrop "]")
                ((Some newShortcuts)
                    (extractKeyboardShortcuts str stream (+ shortcuts (newShortcuts.toLowerCase))))
                (None
                    (warningMessage "unclosed [ in $str")
                    "")))
        (None
            shortcuts)))

(function :Void registerShortcut [keys description &opt :Map<String,ShortcutKey> prefixMap]
    (unless prefixMap (set prefixMap commandShortcuts))
    (let [firstKey (keys.shift)]
        (cond 
            ((prefixMap.exists firstKey)
                (let [existingKey (dictGet prefixMap firstKey)
                        conflictMessage "Keyboard shortcut for $description conflicts with $existingKey"]
                    (if keys
                            // TODO if the existing node is Final, not a branch, throw conflicting message
                            (case existingKey
                                ((Final _)
                                    (warningMessage conflictMessage))
                                ((Prefix innerPrefixMap)
                                    (registerShortcut keys description innerPrefixMap)))
                        (warningMessage conflictMessage))))
            (true
                (if keys
                        (let [innerPrefixMap (new Map)]
                            (dictSet prefixMap firstKey (Prefix innerPrefixMap))
                            (registerShortcut keys description innerPrefixMap))
                    (dictSet prefixMap firstKey (Final description)))))))

(function registerCommand [description command]
    (dictSet commands description command)
    (whenLet [keyboardShortcut (extractKeyboardShortcuts description)]
        (registerShortcut (keyboardShortcut.split "") description)))

// Register a VSCode command (built-in, or from an extension)
(function registerExistingCommand [description command]
    (registerCommand description (lambda :Void [&opt _] (executeCommand command))))

(loadFrom "kiss-vscode" "src/commands/KissTools.kiss")
(loadFrom "kiss-vscode" "src/commands/ExtensionTools.kiss")

(function :Void registerBuiltins []
    (set Prelude.printStr ->:Void s (infoMessage s))
    // In this file:
    (registerCommand "[K]iss: Run a Kiss-VSCode [c]ommand" runCommand)
    (registerCommand "[K]iss: Re-run [l]ast Kiss-VSCode command" runLastCommand)
    (registerCommand "[K]iss: Run a keyboard [s]hortcut command" runKeyboardShortcut)
    // KissTools.kiss:
    (registerCommand "[K]iss: [e]valuate and print an expression" evalAndPrint)
    (registerCommand "[K]iss: create [n]ew kiss class" newKissClass)
    (registerCommand "[K]iss: open corresponding .kiss/.hx [f]ile" showCorrespondingFile)
    // ExtensionTools.kiss:
    (registerCommand "[K]iss: [u]pdate Kiss-VSCode" updateKissVscode)
    (registerCommand "[K]iss: [t]est and [u]pdate Kiss-VSCode" testAndUpdateKissVscode))

// TODO standardize this with KissInterp
(function :Void prepareInterp []
    (interp.variables.set "kiss" 
        (object
            Prelude
                Prelude))
            //interp.variables.set("Helpers", Helpers);
    (interp.variables.set "Prelude" Prelude)
    (interp.variables.set "Lambda" Lambda)
    (interp.variables.set "Vscode" Vscode)
    // TODO for some reason, (interp.variables.set "Std" Std) doesn't capture
    // some static functions, like parseInt. So this kludgy bit is necessary:
    (interp.variables.set "Std"
        (object
            parseInt Std.parseInt
            string Std.string
            random Std.random
            int Std.int)))

(#unless test
    (var :Array<KTxt2Conversion> conversions [])

    (function registerConversion [:KTxt2Conversion conversion] (conversions.push conversion)))