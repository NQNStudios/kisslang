(function userHome [] (or (Sys.getEnv "MSYSHOME") (Sys.getEnv "HOME") (Sys.getEnv "UserProfile")))
(function userConfigDir []
    (joinPath
        (userHome) 
        ".kiss"))

(var &mut activeConfigDir "")
(var &mut lastConfigDir "")
(var &mut builtinConfigDir "")
(var &mut :KissConfig config null)

(function walkDirectory [basePath directory :String->Void processFile :String->Void processSubdirectory]
    (doFor fileOrFolder (FileSystem.readDirectory (joinPath basePath directory))
        (case fileOrFolder
            ((when (FileSystem.isDirectory (joinPath basePath directory folder)) folder)
                (let [subdirectory (joinPath directory folder)]
                    (processSubdirectory subdirectory)
                    (walkDirectory basePath subdirectory processFile processSubdirectory)))
            (file
                (processFile (joinPath directory file))))))

(function :Void tryLoadConfig [&opt :String text]
    // TODO if a config object is active and a shortcut panel is open, dispose the panel before we lose the handle in the current config object

    // If a backup exists, delete it
    (when (FileSystem.exists lastConfigDir)
        (FileSystem.deleteDirectory lastConfigDir))
    // Backup currently active config
    // TODO maybe also expose that backup to the user via a "rollback .kiss" command so they can rollback their config without using Git?
    (when (FileSystem.exists activeConfigDir)
        (FileSystem.rename activeConfigDir lastConfigDir))
    // Choose where to find the custom config
    (let [customConfigDir
                (#if test
                        // When running unit tests, build the example config
                        (joinPath builtinConfigDir "example")
                    // When running for real, try the user's config directory
                    (if (FileSystem.exists (userConfigDir))
                            (userConfigDir)
                        // Supply the default (empty) config if the user doesn't have one
                        (joinPath builtinConfigDir "default")))]
        (FileSystem.createDirectory activeConfigDir)
        // Copy the boilerplate config files to the active config directory
        (doFor file (FileSystem.readDirectory builtinConfigDir)
            (unless (FileSystem.isDirectory (joinPath builtinConfigDir file))
                (File.copy
                    (joinPath builtinConfigDir file)
                    (joinPath activeConfigDir file))))
        // Recursively copy the user's custom config files to the active config directory
        (walkDirectory customConfigDir null
            ->file
                (File.copy
                    (joinPath customConfigDir file)
                    (joinPath activeConfigDir file))
            ->folder
                (FileSystem.createDirectory
                    (joinPath activeConfigDir folder)))
        // When running from unit tests, install all dependencies in the example config:
        (#when test (ChildProcess.spawnSync "haxelib" ["install" "all"] (object cwd activeConfigDir)))
        // Run the haxe compiler:
        (let [buildResult
                    (ChildProcess.spawnSync "haxe" ["build.hxml"] (object cwd activeConfigDir))]
            (if (and !buildResult.error (= 0 buildResult.status))
                    // Successful compilation!
                    (#if test
                            // When testing:
                            (print "Example config compiled successfully")
                        // When running the extension:
                        // Require the config.js package that was generated.
                        // But since Node.require() caches modules by filename,
                        // copy it to a unique path first so hot-reloading works properly.
                        (let [activeConfigFile (joinPath activeConfigDir "config.js")
                                uniqueConfigFile (joinPath activeConfigDir "$(.toShort (Uuid.v4)).js")]
                            (File.copy activeConfigFile uniqueConfigFile)
                            (set config (the KissConfig .KissConfig (Node.require uniqueConfigFile)))
                            // (FileSystem.deleteFile uniqueConfigFile)
                            (config.registerBuiltins)
                            (config.registerCommand "[r]eload Kiss config" tryLoadConfig)
                            (config.prepareInterp)
                            // User-defined init:
                            (config.init)
                            (Vscode.window.showInformationMessage "Config loaded successfully!")))
                // Failed compilation!
                (begin
                    (FileSystem.deleteDirectory activeConfigDir)
                    (when (FileSystem.exists lastConfigDir)
                        (FileSystem.rename lastConfigDir activeConfigDir))
                        (let [errorMessage
                                    (+ "Config failed to compile: "
                                        (if buildResult.error 
                                                #| "" + buildResult.error|#
                                            #| "" + buildResult.stderr |#))]
                            (#if test
                                    // If there's a build error when testing, throw a test failure
                                    (throw errorMessage)
                                // If there's a build error at runtime, tell the user
                                (Vscode.window.showErrorMessage errorMessage))))))))

(#unless test
    (function _activate [:ExtensionContext context]
        (context.subscriptions.push
            (Vscode.commands.registerCommand
                "kiss.reloadConfig"
                tryLoadConfig))

        (context.subscriptions.push
            (Vscode.commands.registerCommand
                "kiss.runCommand"
                (lambda :Void [] 
                    (if config
                            (.runCommand (the KissConfig config))
                        (Vscode.window.showErrorMessage "Can't run commands! No config is loaded.")))))

        (context.subscriptions.push
            (Vscode.commands.registerCommand
                "kiss.runLastCommand"
                (lambda :Void [] 
                    (if config
                            (.runLastCommand (the KissConfig config))
                        (Vscode.window.showErrorMessage "Can't run commands! No config is loaded.")))))

        (context.subscriptions.push
            (Vscode.commands.registerCommand
                "kiss.runKeyboardShortcut"
                (lambda :Void [] 
                    (if config
                            (.runKeyboardShortcut (the KissConfig config))
                        (Vscode.window.showErrorMessage "Can't run commands! No config is loaded.")))))

        // TODO overload Prelude.print to use showInformationMessage

        (set builtinConfigDir (joinPath context.extensionPath "config"))
        (set activeConfigDir (joinPath (userHome) ".kiss-vscode" "activeConfig"))
        (set lastConfigDir (joinPath (userHome) ".kiss-vscode" "lastActiveConfig"))
        (tryLoadConfig)))

(function :Void main []
    (#when test
        (set builtinConfigDir "config")
        (set activeConfigDir "_activeConfig")
        (set lastConfigDir "_lastActiveConfig")
        (tryLoadConfig)
        // Load the config twice more to make sure it moves the last active config out of the way properly:
        (tryLoadConfig)
        (tryLoadConfig)))
