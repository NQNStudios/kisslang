(defun userConfigDir []
    (Path.join [
        (or (Sys.getEnv "MSYSHOME") (Sys.getEnv "HOME") (Sys.getEnv "UserProfile"))
        ".kiss"]))

(defvar &mut activeConfigDir "")
(defvar &mut lastConfigDir "")
(defvar &mut builtinConfigDir "")
(defvar &mut :KissConfig config null)

(defun :Void tryLoadConfig [&opt :String text]
    // TODO if a config object is active and a shortcut panel is open, dispose the panel before we lose the handle in the current config object

    // If a backup exists, delete it
    (when (FileSystem.exists lastConfigDir)
        (FileSystem.deleteDirectory lastConfigDir))
    // Backup currently active config
    // TODO maybe also expose that backup to the user via a "rollback .kiss" command so they can rollback their config without using Git?
    (when (FileSystem.exists activeConfigDir)
        (FileSystem.rename activeConfigDir lastConfigDir))
    // Choose where to find the custom config
    (let [customConfigDir
                (#if test
                        // When running unit tests, build the example config
                        (Path.join [builtinConfigDir "example"])
                    // When running for real, try the user's config directory
                    (if (FileSystem.exists (userConfigDir))
                            (userConfigDir)
                        // Supply the default (empty) config if the user doesn't have one
                        (Path.join [builtinConfigDir "default"])))
                
            // TODO this isn't recursive, so it doesn't allow the user to organize their config with folders
            // TODO it would also attempt to copy over any documentation cache in the .kiss directory, but does File.copy work on directories?
            customConfigFiles
                (FileSystem.readDirectory customConfigDir)]
        (FileSystem.createDirectory activeConfigDir)
        // Copy the boilerplate config files to the active config directory
        (doFor file ["build.hxml" "KissConfig.hx" "KissConfig.kiss"]
            (File.copy
                (Path.join [builtinConfigDir file])
                (Path.join [activeConfigDir file])))
        // Copy the user's custom config files to the active config directory
        (doFor file customConfigFiles
            (File.copy
                (Path.join [customConfigDir file])
                (Path.join [activeConfigDir file])))
        // When running from unit tests, install all dependencies in the example config:
        (#when test (ChildProcess.spawnSync "haxelib" ["install" "all"] (object cwd activeConfigDir)))
        // Run the haxe compiler:
        (let [buildResult
                    (ChildProcess.spawnSync "haxe" ["build.hxml"] (object cwd activeConfigDir))]
            (if (and !buildResult.error (= 0 buildResult.status))
                    // Successful compilation!
                    (#unless test
                        // Require the config.js package.
                        // But since Node.require() caches modules by filename,
                        // copy it to a unique path first so hot-reloading works properly.
                        (let [activeConfigFile (Path.join [activeConfigDir "config.js"])
                                uniqueConfigFile (Path.join [activeConfigDir "$(.toShort (Uuid.v4)).js"])]
                            (File.copy activeConfigFile uniqueConfigFile)
                            (set config (the KissConfig .KissConfig (Node.require uniqueConfigFile)))
                            // (FileSystem.deleteFile uniqueConfigFile)
                            (config.registerBuiltins)
                            (config.registerCommand "[r]eload Kiss config" tryLoadConfig)
                            (config.prepareInterp)
                            // User-defined init:
                            (#unless test
                                (config.init)
                                (Vscode.window.showInformationMessage "Config loaded successfully!"))))
                // Failed compilation!
                (begin
                    (FileSystem.deleteDirectory activeConfigDir)
                    (when (FileSystem.exists lastConfigDir)
                        (FileSystem.rename lastConfigDir activeConfigDir))
                        (let [errorMessage
                                    (+ "Config failed to compile: "
                                        (if buildResult.error 
                                                #| "" + buildResult.error|#
                                            #| "" + buildResult.stderr |#))]
                            (#if test
                                    // If there's a build error when testing, throw a test failure
                                    (throw errorMessage)
                                // If there's a build error at runtime, tell the user
                                (Vscode.window.showErrorMessage errorMessage))))))))

(#unless test
    (defun _activate [:ExtensionContext context]
        (context.subscriptions.push
            (Vscode.commands.registerCommand
                "kiss.reloadConfig"
                tryLoadConfig))

        (context.subscriptions.push
            (Vscode.commands.registerCommand
                "kiss.runCommand"
                (lambda :Void [] 
                    (if config
                            (.runCommand (the KissConfig config))
                        (Vscode.window.showErrorMessage "Can't run commands! No config is loaded.")))))

        (context.subscriptions.push
            (Vscode.commands.registerCommand
                "kiss.runLastCommand"
                (lambda :Void [] 
                    (if config
                            (.runLastCommand (the KissConfig config))
                        (Vscode.window.showErrorMessage "Can't run commands! No config is loaded.")))))

        (context.subscriptions.push
            (Vscode.commands.registerCommand
                "kiss.runKeyboardShortcut"
                (lambda :Void [] 
                    (if config
                            (.runKeyboardShortcut (the KissConfig config))
                        (Vscode.window.showErrorMessage "Can't run commands! No config is loaded.")))))

        // TODO overload Prelude.print to use showInformationMessage

        (set builtinConfigDir (Path.join [context.extensionPath "config"]))
        (set activeConfigDir (Path.join [context.extensionPath "_activeConfig"]))
        (set lastConfigDir (Path.join [context.extensionPath "_lastActiveConfig"]))
        (tryLoadConfig)))

(defun :Void main []
    (#when test
        // TODO 
        (set builtinConfigDir "config")
        (set activeConfigDir "_activeConfig")
        (set lastConfigDir "_lastActiveConfig")
        (tryLoadConfig)))