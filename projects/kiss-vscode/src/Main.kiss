(load "Util.kiss")

(function userHome [] (or (Sys.getEnv "MSYSHOME") (Sys.getEnv "HOME") (Sys.getEnv "UserProfile")))
(function userConfigDir []
    (joinPath
        (userHome) 
        ".kiss"))

(var &mut activeConfigDir "")
(var &mut lastConfigDir "")
(var &mut builtinConfigDir "")
(var &mut :KissConfig config null)

(function :Void tryLoadConfig [&opt :String text]
    (let [handleConfigFailure
                ->errorMessage {
                    (FileSystem.deleteDirectory activeConfigDir)
                    (when (FileSystem.exists lastConfigDir)
                        (FileSystem.rename lastConfigDir activeConfigDir))
                    (#if test
                            // If there's a build error when testing, throw a test failure
                            (throw errorMessage)
                        // If there's a build error at runtime, tell the user
                        (Vscode.window.showErrorMessage errorMessage))
                }]
        // If a backup exists, delete it
        (when (FileSystem.exists lastConfigDir)
            (FileSystem.deleteDirectory lastConfigDir))
        // Backup currently active config
        // TODO maybe also expose that backup to the user via a "rollback .kiss" command so they can rollback their config without using Git?
        (when (FileSystem.exists activeConfigDir)
            (FileSystem.rename activeConfigDir lastConfigDir))
        // Choose where to find the custom config
        (let [customConfigDir
                    (#if test
                            // When running unit tests, build the example config
                            (joinPath builtinConfigDir "example")
                        // When running for real, try the user's config directory
                        (if (FileSystem.exists (userConfigDir))
                                (userConfigDir)
                            // Supply the default (empty) config if the user doesn't have one
                            (joinPath builtinConfigDir "default")))]
            (FileSystem.createDirectory activeConfigDir)
            // Copy the boilerplate config files to the active config directory
            (doFor file (FileSystem.readDirectory builtinConfigDir)
                (unless (FileSystem.isDirectory (joinPath builtinConfigDir file))
                    (File.copy
                        (joinPath builtinConfigDir file)
                        (joinPath activeConfigDir file))))
            // Recursively copy the user's custom config files to the active config directory
            (walkDirectory customConfigDir null
                ->file
                    (File.copy
                        (joinPath customConfigDir file)
                        (joinPath activeConfigDir file))
                ->folder
                    (FileSystem.createDirectory
                        (joinPath activeConfigDir folder)))
            // install all Haxe dependencies:
            (trySpawnSync "haxelib" ["install" "all" "--always"] (object cwd activeConfigDir) handleConfigFailure)
            // install all Node dependencies:
            (when (FileSystem.exists (joinPath activeConfigDir "package.json"))
                (if (= "Windows" (Sys.systemName))
                        (trySpawnSync "cmd.exe" ["/c" "npm" "install"] (object cwd activeConfigDir) handleConfigFailure)
                    (trySpawnSync "npm" ["install"] (object cwd activeConfigDir) handleConfigFailure)))
            // Run the haxe compiler:
            (trySpawnSync "haxe" ["build.hxml"] (object cwd activeConfigDir) handleConfigFailure)

            // Successful compilation!
            (#if test
                    // When testing:
                    (print "Example config compiled successfully")
                // When running the extension:
                // Require the config.js package that was generated.
                // But since Node.require() caches modules by filename,
                // copy it to a unique path first so hot-reloading works properly.
                (let [activeConfigFile (joinPath activeConfigDir "config.js")
                        uniqueConfigFile (joinPath activeConfigDir "$(.toShort (Uuid.v4)).js")]
                    (File.copy activeConfigFile uniqueConfigFile)
                    (set config (the KissConfig .KissConfig (Node.require uniqueConfigFile)))
                    // (FileSystem.deleteFile uniqueConfigFile)
                    (config.registerBuiltins)
                    (config.registerCommand "[K]iss: [r]eload Kiss config" tryLoadConfig)
                    (config.prepareInterp)
                    // User-defined init:
                    (config.init)
                    (Vscode.window.showInformationMessage "Config loaded successfully!"))))))

    (#unless test
    (function _activate [:ExtensionContext context]
        (context.subscriptions.push
            (Vscode.commands.registerCommand
                "kiss.reloadConfig"
                tryLoadConfig))

        (context.subscriptions.push
            (Vscode.commands.registerCommand
                "kiss.runCommand"
                (lambda :Void [] 
                    (if config
                            (.runCommand (the KissConfig config))
                        (Vscode.window.showErrorMessage "Can't run commands! No config is loaded.")))))

        (context.subscriptions.push
            (Vscode.commands.registerCommand
                "kiss.runLastCommand"
                (lambda :Void [] 
                    (if config
                            (.runLastCommand (the KissConfig config))
                        (Vscode.window.showErrorMessage "Can't run commands! No config is loaded.")))))

        (context.subscriptions.push
            (Vscode.commands.registerCommand
                "kiss.runKeyboardShortcut"
                (lambda :Void [] 
                    (if config
                            (.runKeyboardShortcut (the KissConfig config))
                        (Vscode.window.showErrorMessage "Can't run commands! No config is loaded.")))))

        (context.subscriptions.push
            (KTxt2EditorProvider.register context))

        (set builtinConfigDir (joinPath context.extensionPath "config"))
        (set activeConfigDir (joinPath (userHome) ".kiss-vscode" "activeConfig"))
        (set lastConfigDir (joinPath (userHome) ".kiss-vscode" "lastActiveConfig"))

        // TODO for some reason the custom ktxt2 editor is not available until this completes, even if it is
        // invoked asynchronously: 
        (tryLoadConfig)))

// Manually define main so it will exist when test is not defined:
(function :Void main []
    (#when test
        (set builtinConfigDir "config")
        (set activeConfigDir "_activeConfig")
        (set lastConfigDir "_lastActiveConfig")
        (tryLoadConfig)
        // Load the config twice more to make sure it moves the last active config out of the way properly:
        (tryLoadConfig)
        (tryLoadConfig)))
