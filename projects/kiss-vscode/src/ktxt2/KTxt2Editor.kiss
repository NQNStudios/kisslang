(var &mut :VSCodeAPI vscode)
(var &mut :Window window)
(var &mut :Document document)
(var &mut :Element content)
(var &mut :Array<KTxt2Element> ktxt2Elements)

(function main []
    (set vscode (EditorExterns.acquireVsCodeApi))
    (set window EditorExterns.window)
    (set document window.document)

    (set Prelude.printStr ->[message]
        (vscode.postMessage (object type "print" text message)))

    (window.addEventListener "message"
        ->:Void event
            (case (the MessageToEditor event.data)
                ((object type "update" text text)
                    (updateContent text)
                    (vscode.setState (object text text)))
                (otherType (throw "bad message $event for KTxt2Editor"))))
    
    (whenLet [state (the Dynamic (vscode.getState))]
        (updateContent state.text)))

(var &mut :Map<Int,Int> editTimeoutHandles (new Map))
(var EDIT_TIMEOUT_MILLI 1000)
(function :Void addEditTimeout [idx :Void->Void handler]
    (whenLet [activeTimeoutForIndex (dictGet editTimeoutHandles idx)]
        (window.clearTimeout activeTimeoutForIndex))
    (dictSet editTimeoutHandles
        idx
        (window.setTimeout
            ->{
                (editTimeoutHandles.remove idx)
                (handler)
            }
            EDIT_TIMEOUT_MILLI)))

(function commentElements [text idx]
    (let [p (document.createElement "p")
            blockLinkBefore (document.createElement "a")
            blockLinkAfter (document.createElement "a")]
        // Links that allow inserting a block between existing blocks:
        (set blockLinkBefore.innerHTML "+")
        (blockLinkBefore.addEventListener "click"
            ->(insertBlockBeforeComment (nth ktxt2Elements idx)))
        (set blockLinkAfter.innerHTML "+")
        (blockLinkAfter.addEventListener "click"
            ->(insertBlockAfterComment (nth ktxt2Elements idx)))

        // Paragraph displaying and allowing editing the comment
        (set p.innerHTML text)
        (p.setAttribute "style" "white-space: pre;")
        (p.setAttribute "contenteditable" "true")
        (p.addEventListener "input"
            ->(addEditTimeout idx ->(replaceComment (nth ktxt2Elements idx) p.innerHTML)))
        (content.appendChild blockLinkBefore)
        (content.appendChild p)
        (content.appendChild blockLinkAfter)))

(function toPlaintext [:String text]
    (.htmlUnescape
        (.replace
            (.replace
                (text.replace "<div>" "\n")
                "</div>" "")
            "<br>" "\n")))

(function replaceComment [element newText]
    (case element
        ((Comment (object text text start start end end))
            (vscode.postMessage (object type "replace" text (toPlaintext newText) start start end end)))
        (otherwise (throw "element $element is not a comment"))))

(function insertBlockBeforeComment [element]
    (case element
        ((Comment (object start position))
            (vscode.postMessage (object type "insert" text "\n${KTxt2.emptyBlock}" position position)))
        (otherwise (throw "element $element is not a comment"))))

(function insertBlockAfterComment [element]
    (case element
        ((Comment (object end position))
            (vscode.postMessage (object type "insert" text "${KTxt2.emptyBlock}\n" position position)))
        (otherwise (throw "element $element is not a comment"))))

(function replaceSourceBlock [element newText]
    (case element
        ((Block (object source text sourceStart start sourceEnd end))
            (vscode.postMessage (object type "replace" text (toPlaintext newText) start start end end)))
        (otherwise (throw "element $element is not a block"))))

(function replaceOutputBlock [element newText]
    (case element
        ((Block (object output text outputStart start outputEnd end))
            (vscode.postMessage (object type "replace" text (toPlaintext newText) start start end end)))
        (otherwise (throw "element $element is not a block"))))

(function deleteEntireBlock [element]
    (case element
        ((Block (object source text sourceStart start outputEnd end))
            (vscode.postMessage (object type "deleteBlock" start start end end)))
        (otherwise (throw "element $element is not a block"))))

(function changeLockStatus [element newStatus]
    (case element
        ((Block (object sourceEnd start outputStart end))
            (vscode.postMessage (object type "replace" text (if newStatus KTxt2.lockedStart KTxt2.unlockedStart) start start end end)))
        (otherwise (throw "element $element is not a block"))))

(function blockElements [source output locked idx]
    (let [outerDiv (document.createElement "div")
            sourceDiv (document.createElement "div")
            outputDiv (document.createElement "div")
            lockDiv (document.createElement "div")
            xLink (document.createElement "a")
            lockLink (document.createElement "a")]
        (outerDiv.setAttribute "class" "container")
        (outerDiv.setAttribute "style" "display: flex;")
        (sourceDiv.setAttribute "style" "width: 50%; white-space: pre;")
        (sourceDiv.setAttribute "class" "block")
        (sourceDiv.setAttribute "contenteditable" "true")
        (sourceDiv.addEventListener "input"
            ->(addEditTimeout idx ->(replaceSourceBlock (nth ktxt2Elements idx) sourceDiv.innerHTML)))
        (set sourceDiv.innerHTML source)
        (outputDiv.setAttribute "style" "flex-grow: 1; white-space: pre;")
        (outputDiv.setAttribute "class" "block")
        (outputDiv.setAttribute "contenteditable" "true")
        (outputDiv.addEventListener "input"
            ->(addEditTimeout idx ->(replaceOutputBlock (nth ktxt2Elements idx) outputDiv.innerHTML)))
        (set outputDiv.innerHTML output)
        (lockDiv.setAttribute "style" "width: 1ch")
        (if locked
                (set lockDiv.innerHTML "!")
            // TODO add a "generate" button and "lock" button
            )

        // Link that will delete the whole block:
        (set xLink.innerHTML "x")
        (xLink.addEventListener "click"
            ->(deleteEntireBlock (nth ktxt2Elements idx)))
        (unless locked
            (outerDiv.appendChild xLink))

        (outerDiv.appendChild sourceDiv)
        (outerDiv.appendChild lockDiv)
        (outerDiv.appendChild outputDiv)

        (set lockLink.innerHTML (if locked "unlock" "lock"))
        (lockLink.addEventListener "click"
            ->(changeLockStatus (nth ktxt2Elements idx) !locked))
        (outerDiv.appendChild lockLink)

        (content.appendChild outerDiv)))

(function :Void updateContent [text]
    (try
            {
                (when content
                    (document.body.removeChild content))
                (set content (document.createElement "div"))
                (document.body.appendChild content)
                (set ktxt2Elements (KTxt2.splitFileElements (Stream.fromString text)))
                (doFor [idx element] (enumerate ktxt2Elements)
                    (case element
                        ((Comment (objectWith text))
                            (commentElements text idx))
                        ((Block (objectWith source output outputLocked))
                            (blockElements source output outputLocked idx))))
            }
        (catch [error] (print "Error updating ktxt2 editor: ${error}"))))

/*(function exportSourceAndOutputFiles [document]
    (let [[sourceText outputText] (splitFileContents document.fileName)
            ktxt2FullFilename document.fileName
            ktxt2Directory (haxe.io.Path.directory ktxt2FullFilename)
            ktxt2Filename (haxe.io.Path.withoutDirectory ktxt2FullFilename)
            [baseFilename sourceExt outputExt ktxt2Ext] (ktxt2Filename.split ".")
            sourceFilename (joinPath ktxt2Directory "${baseFilename}.${sourceExt}")
            outputFilename (joinPath ktxt2Directory "${baseFilename}.${outputExt}")]
        // Use editors instead of File.saveContent for this, so the user can undo the export if
        // it overwrites something!
        (defMacro overwriteDocument [document content]
            `(let [document ,document content ,content]
                (awaitLet [editor (Vscode.window.showTextDocument document)]
                    (editor.edit
                        ->e (e.replace (new Range (document.positionAt 0) (document.positionAt .length (document.getText))) content)))))
        (function uriFor [filename]
            (let [uri (Uri.file filename)]
                (if (sys.FileSystem.exists filename)
                        uri
                    (uri.with (object scheme "untitled")))))
        (awaitLet [sourceDocument
                        (Vscode.workspace.openTextDocument (uriFor sourceFilename))
                    sourceEditSuccess
                        (overwriteDocument sourceDocument sourceText)
                    outputDocument
                        (Vscode.workspace.openTextDocument (uriFor outputFilename))
                    outputEditSuccess
                        (overwriteDocument outputDocument outputText)]
            (assert (and sourceEditSuccess outputEditSuccess))
            (awaitLet [saveSourceSuccess
                            (sourceDocument.save)
                        saveOutputSuccess
                            (outputDocument.save)]
                (assert (and saveSourceSuccess saveOutputSuccess))))))

(function splitBlocks [&opt _]
    (let [blocks (splitFileBlocks)] (print blocks)))
*/