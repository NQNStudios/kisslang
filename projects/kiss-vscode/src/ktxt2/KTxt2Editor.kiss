(var &mut :VSCodeAPI vscode)
(var &mut :Window window)
(var &mut :Document document)
(var &mut :Element content)
(var &mut :Array<KTxt2Element> ktxt2Elements)

// Because monaco editors are expensive, the editor can't have an infinite number open at a time
(var PAGE_SIZE 24)
(var SCROLL_AMOUNT 18)
(var &mut elementScrollY 0)

(function :EditorState getState []
    (ifLet [s (the EditorState (vscode.getState))]
            s
        (object
            scrollY 0.0
            elementScrollY 0
            text ""
            activeEditorIdx -1
            startCursorPos -1
            endCursorPos -1)))

(function :Void setState [:EditorState state]
    (vscode.setState state))

(function main []
    (set vscode (EditorExterns.acquireVsCodeApi))
    (set window EditorExterns.window)
    (set document window.document)

    (set Prelude.printStr ->[message]
        (vscode.postMessage (object type "print" text message)))

    (window.addEventListener "message"
        ->:Void event
            (case (the MessageToEditor event.data)
                ((object type "update" text text)
                    // Either create the first EditorState, or get the last one
                    (let [newState (getState)]
                        (set newState.text text)
                        (setState newState)
                        (whenMonacoIsAvailable
                            ->{
                                (updateContent text)
                                (activateFromState newState)
                            })))
                (otherType (throw "bad message $event for KTxt2Editor"))))
    
    (window.addEventListener "scroll"
        ->(let [s (getState)]
            (set s.scrollY window.scrollY)
            (setState s)))

    (window.addEventListener "keydown" ->:Void e
        (unless activeEditor
            (case e.key
                ("g" (pageTop))
                ("v" (pageBottom))
                ("ArrowUp" (pageUp))
                ("ArrowDown" (pageDown))
                ("ArrowLeft" (scrollToPageTop))
                ("ArrowRight" (scrollToPageBottom))
                ("s" (export))
                (otherwise))))

    // Don't use getState helper here because we don't want to force updateContent with blank text
    (whenLet [state (the EditorState (vscode.getState))]
        // Reload the editor after it has been hidden:
        // Wait to set up the UI until monaco is loaded from the other scripts:
        (whenMonacoIsAvailable ->{
            (set elementScrollY state.elementScrollY)
            (updateContent state.text)
            (setScrollY state.scrollY)
            (activateFromState state)
        })))

(function activateFromState [state]
    (when (<= 0 state.activeEditorIdx)
        (let [e (nth editors state.activeEditorIdx)]
            (e.focus)
            (if (<= 0 state.endCursorPos)
                    {
                        (e.setSelection
                            (Range.fromPositions
                                (.getPositionAt (e.getModel) state.startCursorPos)
                                (.getPositionAt (e.getModel) state.endCursorPos)))
                    }
                (if (<= 0 state.startCursorPos)
                        {
                            (e.setPosition (.getPositionAt (e.getModel) state.startCursorPos))
                        })))
                ((activateEditor state.activeEditorIdx))))

(var MONACO_CHECK_MILLI 100)
(function :Void whenMonacoIsAvailable [:Void->Void doThis]
    (if Lib.global.monaco
            {
                (set Range Lib.global.monaco.Range)
                (doThis)
            }
        (window.setTimeout ->(whenMonacoIsAvailable doThis) MONACO_CHECK_MILLI)))

(var &mut :Map<Int,Int> editTimeoutHandles (new Map))
(var EDIT_TIMEOUT_MILLI 4000)
(var EXPORT_TIMEOUT_MILLI 10000)
(var &mut :Array<Int> exportTimeoutHandle [])
(function :Void addEditTimeout [idx :Void->Void handler]
    (whenLet [activeTimeoutForIndex (dictGet editTimeoutHandles idx)]
        (window.clearTimeout activeTimeoutForIndex))
    (whenLet [[activeExportTimeout] exportTimeoutHandle]
        (window.clearTimeout activeExportTimeout))
    (dictSet editTimeoutHandles
        idx
        (window.setTimeout
            ->{
                (editTimeoutHandles.remove idx)
                (handler)
            }
            EDIT_TIMEOUT_MILLI))
    (set exportTimeoutHandle
        [
            (window.setTimeout ->{
                (set exportTimeoutHandle [])
                (export)
            }
            EXPORT_TIMEOUT_MILLI)
        ]))

(var &mut :Dynamic activeEditor)
(var &mut :Array<Dynamic> editors [])
(function monacoEditor [div style content language readOnly :Dynamic->Void onChange]
    (let [eIdx
                editors.length
            :Dynamic e
                (Lib.global.monaco.editor.create div
                    (objectWith
                        [
                            value content
                            lineNumbers "on"
                            scrollBeyondLastLine false
                            theme "vs-dark"
                            minimap (object enabled false)
                            wordWrap true
                        ]
                        language
                        readOnly))
            updateSize
                ->[&opt _] {
                    (div.setAttribute "style" "${style} height: $(e.getContentHeight)px;")
                    (e.layout)
                }]
        (updateSize)
        (e.onDidFocusEditorText (activateEditor eIdx))
        (e.onDidChangeCursorPosition
            ->evt
                (when (Range.isEmpty (activeEditor.getSelection))
                    (let [s (getState)]
                        (set s.startCursorPos (.getOffsetAt (e.getModel) evt.position))
                        (set s.endCursorPos -1)
                        (setState s))

                    // Delay updating the block
                    (when (dictGet editTimeoutHandles eIdx)
                        (onChange e))))
        (e.onDidChangeCursorSelection
            ->evt {
                (let [s (getState)]
                    (set s.startCursorPos (.getOffsetAt (e.getModel) (evt.selection.getStartPosition)))
                    (set s.endCursorPos (.getOffsetAt (e.getModel) (evt.selection.getEndPosition)))
                    (setState s))
                
                // Delay updating the block
                (when (dictGet editTimeoutHandles eIdx)
                    (onChange e))
            })
        (e.onDidBlurEditorText (deactivateEditor eIdx))
        (e.onDidContentSizeChange updateSize)
        (e.onDidChangeModelContent
            ->[&opt _] {
                (let [s (getState)]
                    (set s.activeEditorIdx eIdx)
                    (set s.startCursorPos (.getOffsetAt (e.getModel) (e.getPosition)))
                    (set s.endCursorPos -1)
                    (setState s))
                (onChange e)
            })
        (editors.push e)
        e))

(var &mut :Dynamic Range)

(function activateEditor [eIdx]
    ->{
        (set activeEditor (nth editors eIdx))
        (let [s (getState)]
            (set s.activeEditorIdx eIdx)
            (let [sel (activeEditor.getSelection)]
                (if (Range.isEmpty sel)
                        // set state's cursor position
                        {
                            (set s.startCursorPos (activeEditor.getOffsetAt (activeEditor.getPosition)))
                            (set s.endCursorPos -1)
                        }
                    // set state's selection
                    {
                        (set s.startCursorPos (activeEditor.getOffsetAt (sel.getStartPosition)))
                        (set s.endCursorPos (activeEditor.getOffsetAt (sel.getEndPosition)))
                    }))
            (setState s))
    })

(function deactivateEditor [eIdx]
    ->(when (= activeEditor (nth editors eIdx))
        (set activeEditor null)
        (let [s (getState)]
            (set s.activeEditorIdx -1)
            (set s.startCursorPos -1)
            (set s.endCursorPos -1)
            (setState s))))

(function replaceComment [element newText]
    (case element
        ((Comment (object text text start start end end))
            (vscode.postMessage (object type "replace" text newText start start end end)))
        (otherwise (throw "element $element is not a comment"))))

(function insertBlockBeforeBlock [element]
    (case element
        ((Block (object sourceStart position))
            (vscode.postMessage (object type "insertBefore" text "\n${KTxt2.emptyBlock}" position position)))
        (otherwise (throw "element $element is not a block"))))

(function insertBlockAfterBlock [element]
    (case element
        ((Block (object outputEnd position))
            (vscode.postMessage (object type "insertAfter" text "${KTxt2.emptyBlock}\n" position position)))
        (otherwise (throw "element $element is not a block"))))

(function replaceSourceBlock [element newText]
    (case element
        ((Block (object source text sourceStart start sourceEnd end))
            (vscode.postMessage (object type "replace" text newText start start end end)))
        (otherwise (throw "element $element is not a block"))))

(function replaceOutputBlock [element newText]
    (case element
        ((Block (object output text outputStart start outputEnd end))
            (vscode.postMessage (object type "replace" text newText start start end end)))
        (otherwise (throw "element $element is not a block"))))

(function deleteEntireBlock [element]
    (case element
        ((Block (object source text sourceStart start outputEnd end))
            (vscode.postMessage (object type "deleteBlock" start start end end)))
        (otherwise (throw "element $element is not a block"))))

(function changeLockStatus [element newStatus]
    (case element
        ((Block (object sourceEnd start outputStart end))
            (vscode.postMessage (object type "replace" text (if newStatus KTxt2.lockedStart KTxt2.unlockedStart) start start end end)))
        (otherwise (throw "element $element is not a block"))))

(function tryAutoConvert [element]
    (case element
        ((Block (objectWith source output outputStart outputEnd))
            (vscode.postMessage (objectWith [type "tryAutoConvert"] source output outputStart outputEnd)))
        (otherwise (throw "element $element is not a block"))))

(function blockElements [source output locked idx]
    (let [outerDiv (document.createElement "div")
            :js.html.Element sourceDiv (cast (document.createElement "div"))
            :js.html.Element outputDiv (cast (document.createElement "div"))
            convertLink (document.createElement "a")
            xLink (document.createElement "a")
            lockLink (document.createElement "a")
            exportLink (document.createElement "a")
            blockLinkBefore (document.createElement "a")
            blockLinkAfter (document.createElement "a") ]
        (outerDiv.setAttribute "class" "container")
        (outerDiv.setAttribute "style" "display: flex;")

        (set blockLinkBefore.innerHTML "+")
        (blockLinkBefore.addEventListener "click"
            ->(insertBlockBeforeBlock (nth ktxt2Elements idx)))
        (set blockLinkAfter.innerHTML "+")
        (blockLinkAfter.addEventListener "click"
            ->(insertBlockAfterBlock (nth ktxt2Elements idx)))

        (content.appendChild blockLinkBefore)
        (content.appendChild (document.createElement "br"))

        (monacoEditor sourceDiv "width: 50%;" source /* TODO get the real extension of the source file: */ "txt" locked
            ->editor (addEditTimeout idx ->{
                                            (replaceSourceBlock (nth ktxt2Elements idx) (editor.getValue))
                                        }))

        (monacoEditor outputDiv "flex-grow: 1;" output /* TODO get the real extension of the output file: */ "txt" locked
            ->editor (addEditTimeout idx ->{
                                            (replaceOutputBlock (nth ktxt2Elements idx) (editor.getValue))
                                        }))

        // Link that will delete the whole block:
        (set xLink.innerHTML "x")
        (xLink.addEventListener "click"
            ->(deleteEntireBlock (nth ktxt2Elements idx)))
        (unless locked
            (outerDiv.appendChild xLink))

        (outerDiv.appendChild sourceDiv)

        // Link that attempts automatic conversion of the source in a block:
        (unless locked
            (set convertLink.innerHTML ">")
            (convertLink.setAttribute "style" "width: 2ch;")
            (convertLink.addEventListener "click"
                ->(tryAutoConvert (nth ktxt2Elements idx)))
            (outerDiv.appendChild convertLink))

        (outerDiv.appendChild outputDiv)

        (set lockLink.innerHTML (if locked "unlock " "lock "))
        (lockLink.addEventListener "click"
            ->(changeLockStatus (nth ktxt2Elements idx) !locked))
        (outerDiv.appendChild lockLink)
        (set exportLink.innerHTML "export")
        (exportLink.addEventListener "click" export)
        (outerDiv.appendChild exportLink)
        (content.appendChild outerDiv)
        (content.appendChild (document.createElement "br"))
        (content.appendChild blockLinkAfter)))

(var &mut updatingContent false)

(function :Void setScrollY [y]
    (window.scroll
        (object
            left 0
            top y
            behavior INSTANT)))

(function :Void changeElementScrollY [:Void->Void changeFunc]
    (changeFunc)
    (clamp elementScrollY 0 (- ktxt2Elements.length PAGE_SIZE))
    (let [s (getState)]
        (set s.elementScrollY elementScrollY)
        (setState s))
    (updateContent))

(function :Void updateContent [&opt text]
    (try
            {
                (set updatingContent true)
                (set editors [])
                (when content
                    (document.body.removeChild content))
                (set content (document.createElement "div"))
                (document.body.appendChild content)
                (when text (set ktxt2Elements (KTxt2.splitFileElements (Stream.fromString text))))
                (when (< 0 elementScrollY)
                    (let [upLink (document.createElement "a")
                            topLink (document.createElement "a")]
                        (set upLink.innerHTML "^ ")
                        (set topLink.innerHTML "^^^")
                        (upLink.addEventListener "click" pageUp)
                        (topLink.addEventListener "click" pageTop)
                        (content.appendChild upLink)
                        (content.appendChild topLink)))
                (doFor [idx element] (.slice (collect (enumerate ktxt2Elements)) elementScrollY (+ elementScrollY PAGE_SIZE))
                    (case element
                        ((Comment (objectWith text))
                            (throw "comments are no longer a feature!"))
                        ((Block (objectWith source output outputLocked))
                            (blockElements source output outputLocked idx))))
                (when (> (- ktxt2Elements.length 1) (+ elementScrollY SCROLL_AMOUNT))
                    (let [downLink (document.createElement "a")
                            bottomLink (document.createElement "a")]
                        (set downLink.innerHTML "v ")
                        (set bottomLink.innerHTML "vvv")
                        (downLink.addEventListener "click" pageDown)
                        (bottomLink.addEventListener "click" pageBottom)
                        (content.appendChild downLink)
                        (content.appendChild bottomLink)))
                (set updatingContent false)
            }
        (catch [error] (print "Error updating ktxt2 editor: ${error}"))))

(function scrollToPageTop []
    (setScrollY 0))

(function scrollToPageBottom []
    (setScrollY (- document.body.scrollHeight document.documentElement.clientHeight)))

(function pageDown []
    (changeElementScrollY ->(+= elementScrollY SCROLL_AMOUNT))
    (scrollToPageTop))

(function pageBottom []
    (changeElementScrollY ->(set elementScrollY (- ktxt2Elements.length PAGE_SIZE)))
    (scrollToPageBottom))

(function pageUp []
    (changeElementScrollY ->(-= elementScrollY SCROLL_AMOUNT))
    (scrollToPageBottom))

(function pageTop []
    (changeElementScrollY ->(set elementScrollY 0))
    (scrollToPageTop))

(function export []
    (vscode.postMessage (object type "export")))