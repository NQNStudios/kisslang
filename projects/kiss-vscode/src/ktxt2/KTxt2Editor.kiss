(var &mut :VSCodeAPI _vscode)
(var &mut :Window window)
(var &mut :Document document)
(var &mut :Element content)
(var &mut :Array<KTxt2Element> ktxt2Elements)

// Because monaco editors are expensive, the editor can't have an infinite number open at a time
(var PAGE_SIZE 24)
(var SCROLL_AMOUNT 22)
(var &mut elementScrollY 0)

(function :EditorState getState []
    (ifLet [s (the EditorState (_vscode.getState))]
            s
        (object
            scrollY 0.0
            elementScrollY 0
            text ""
            activeEditorIdx -1
            startCursorPos -1
            endCursorPos -1
            lastSearch "")))

(function :Void setState [:EditorState state]
    (_vscode.setState state))

(defMacro changeState [s &body b]
    `(let [,s (getState)]
        ,@b
        (setState ,s)))

(function main []
    (set _vscode (EditorExterns.acquireVsCodeApi))
    (set window EditorExterns.window)
    (set document window.document)

    (set Prelude.printStr ->[message]
        (_vscode.postMessage (object type "print" text message)))

    (window.addEventListener "message"
        ->:Void event
            (case (the MessageToEditor event.data)
                ((objectWith [type "update"] text)
                    // Either create the first EditorState, or get the last one
                    (changeState newState
                        (set newState.text text)
                        (whenMonacoIsAvailable
                            ->{
                                (updateContent "told by the provider" text)
                                (activateFromState newState)
                            })))
                ((objectWith [type "find"] text)
                    (_find text))
                (otherwise (throw "bad message $event for KTxt2Editor"))))
    
    (window.addEventListener "scroll"
        ->(changeState s
            (set s.scrollY window.scrollY)))

    (window.addEventListener "keydown" ->:Void e
        (if e.ctrlKey
                (case e.key
                    ("f" (find))
                    ("n" (findNext))
                    (otherwise))
            (unless activeEditor
                (case e.key
                    ("g" (pageTop))
                    ("v" (pageBottom))
                    ("ArrowUp" (pageUp))
                    ("ArrowDown" (pageDown))
                    ("ArrowLeft" (scrollToPageTop))
                    ("ArrowRight" (scrollToPageBottom))
                    ("s" (export))
                    (otherwise)))))

    // Don't use getState helper here because we don't want to force updateContent with blank text
    (whenLet [state (the EditorState (_vscode.getState))]
        // Reload the editor after it has been hidden:
        // Wait to set up the UI until monaco is loaded from the other scripts:
        (whenMonacoIsAvailable ->{
            (set elementScrollY state.elementScrollY)
            (updateContent "was hidden" state.text)
            (setScrollY state.scrollY)
            (activateFromState state)
        })))

(function activateFromState [state]
    (when (<= 0 state.activeEditorIdx)
        (let [e (nth editors state.activeEditorIdx)]
            (e.focus)
            (if (<= 0 state.endCursorPos)
                    {
                        (e.setSelection
                            (Range.fromPositions
                                (.getPositionAt (e.getModel) state.startCursorPos)
                                (.getPositionAt (e.getModel) state.endCursorPos)))
                    }
                (if (<= 0 state.startCursorPos)
                        {
                            (e.setPosition (.getPositionAt (e.getModel) state.startCursorPos))
                        })))
                ((activateEditor state.activeEditorIdx))))

(var MONACO_CHECK_MILLI 100)
(function :Void whenMonacoIsAvailable [:Void->Void doThis]
    (if Lib.global.monaco
            {
                (set Range Lib.global.monaco.Range)
                (doThis)
            }
        (window.setTimeout ->(whenMonacoIsAvailable doThis) MONACO_CHECK_MILLI)))

(var &mut :Map<Int,Int> editTimeoutHandles (new Map))
(var EDIT_TIMEOUT_MILLI 4000)
(var EXPORT_TIMEOUT_MILLI 10000)
(var &mut :Array<Int> exportTimeoutHandle [])
(function :Void addEditTimeout [idx :Void->Void handler]
    (whenLet [activeTimeoutForIndex (dictGet editTimeoutHandles idx)]
        (window.clearTimeout activeTimeoutForIndex))
    (whenLet [[activeExportTimeout] exportTimeoutHandle]
        (window.clearTimeout activeExportTimeout))
    (dictSet editTimeoutHandles
        idx
        (window.setTimeout
            ->{
                (editTimeoutHandles.remove idx)
                (handler)
            }
            EDIT_TIMEOUT_MILLI))
    (set exportTimeoutHandle
        [
            (window.setTimeout ->{
                (set exportTimeoutHandle [])
                (export)
            }
            EXPORT_TIMEOUT_MILLI)
        ]))
(function :Void skipEditTimeout [idx :Void->Void handler]
    (whenLet [activeTimeoutForIndex (dictGet editTimeoutHandles idx)]
        (window.clearTimeout activeTimeoutForIndex)
        (editTimeoutHandles.remove idx)
        (handler)))

(var &mut :Dynamic activeEditor)
(var &mut :Array<Dynamic> editors [])
(var &mut :Array<Disposable> eventSubscriptions [])
(function monacoEditor [div style content language readOnly :Dynamic->Void updateBlock]
    (let [eIdx
                editors.length
            :Dynamic e
                (Lib.global.monaco.editor.create div
                    (objectWith
                        [
                            value content
                            lineNumbers "on"
                            scrollBeyondLastLine false
                            theme "vs-dark"
                            minimap (object enabled false)
                            wordWrap true
                        ]
                        language
                        readOnly))
            updateSize
                ->[&opt _] {
                    (div.setAttribute "style" "${style} height: $(e.getContentHeight)px;")
                    (e.layout)
                }
            onChange
                ->editor (addEditTimeout eIdx ->(updateBlock editor))]
        (updateSize)
        (eventSubscriptions.push (e.onDidFocusEditorText (activateEditor eIdx)))
        (eventSubscriptions.push (e.onDidBlurEditorText ->(skipEditTimeout eIdx ->(updateBlock e))))
        (eventSubscriptions.push (e.onDidChangeCursorPosition
            ->evt
                (when (Range.isEmpty (activeEditor.getSelection))
                    (changeState s
                        (set s.startCursorPos (.getOffsetAt (e.getModel) evt.position))
                        (set s.endCursorPos -1))

                    // Delay updating the block
                    (when (dictGet editTimeoutHandles eIdx)
                        (onChange e)))))
        (eventSubscriptions.push (e.onDidChangeCursorSelection
            ->evt {
                (changeState s
                    (set s.startCursorPos (.getOffsetAt (e.getModel) (evt.selection.getStartPosition)))
                    (set s.endCursorPos (.getOffsetAt (e.getModel) (evt.selection.getEndPosition))))
                
                // Delay updating the block
                (when (dictGet editTimeoutHandles eIdx)
                    (onChange e))
            }))
        (eventSubscriptions.push (e.onDidBlurEditorText (deactivateEditor eIdx)))
        (eventSubscriptions.push (e.onDidContentSizeChange updateSize))
        (eventSubscriptions.push (e.onDidChangeModelContent
            ->[&opt _] {
                (changeState s
                    (set s.activeEditorIdx eIdx)
                    (set s.startCursorPos (.getOffsetAt (e.getModel) (e.getPosition)))
                    (set s.endCursorPos -1))
                (onChange e)
            }))
        (editors.push e)
        e))

(var &mut :Dynamic Range)

(function activateEditor [eIdx]
    ->{
        (set activeEditor (nth editors eIdx))
        (changeState s
            (set s.activeEditorIdx eIdx)
            (let [sel (activeEditor.getSelection)]
                (if (Range.isEmpty sel)
                        // set state's cursor position
                        {
                            (set s.startCursorPos (activeEditor.getOffsetAt (activeEditor.getPosition)))
                            (set s.endCursorPos -1)
                        }
                    // set state's selection
                    {
                        (set s.startCursorPos (activeEditor.getOffsetAt (sel.getStartPosition)))
                        (set s.endCursorPos (activeEditor.getOffsetAt (sel.getEndPosition)))
                    })))
    })

(function deactivateEditor [eIdx]
    ->(when (= activeEditor (nth editors eIdx))
        (set activeEditor null)
        (changeState s
            (set s.activeEditorIdx -1)
            (set s.startCursorPos -1)
            (set s.endCursorPos -1))))

(function :Void postMessage [:Dynamic message]
    // (print "posting $message")
    (_vscode.postMessage message))

(function insertBlockBeforeBlock [element]
    (case element
        ((Block (object sourceStart position))
            (postMessage (object type "insertBefore" text "\n${KTxt2.emptyBlock}" position position)))
        (otherwise (throw "element $element is not a block"))))

(function insertBlockAfterBlock [element]
    (case element
        ((Block (object outputEnd position))
            (postMessage (object type "insertAfter" text "${KTxt2.emptyBlock}\n" position position)))
        (otherwise (throw "element $element is not a block"))))

(function joinBlocks [element nextElement]
    (assertLet [(Block (object sourceStart start source source1 output output1 outputLocked lock1)) element
                    (Block (object outputEnd end source source2 output output2 outputLocked lock2)) nextElement
                    text "${source1}${source2}${KTxt2.unlockedStart}${output1}${output2}"]
        (unless (or lock1 lock2)
            (postMessage (objectWith [type "replace"] start end text)))))

(function replaceSourceBlock [element newText]
    (case element
        ((Block (object source text sourceStart start sourceEnd end))
            (postMessage (object type "replace" text newText start start end end)))
        (otherwise (throw "element $element is not a block"))))

(function replaceOutputBlock [element newText]
    (case element
        ((Block (object output text outputStart start outputEnd end))
            (postMessage (object type "replace" text newText start start end end)))
        (otherwise (throw "element $element is not a block"))))

(function deleteEntireBlock [element]
    (case element
        ((Block (object source text sourceStart start outputEnd end))
            (postMessage (object type "deleteBlock" start start end end)))
        (otherwise (throw "element $element is not a block"))))

(function changeLockStatus [element newStatus]
    (case element
        ((Block (object sourceEnd start outputStart end))
            (postMessage (object type "replace" text (if newStatus KTxt2.lockedStart KTxt2.unlockedStart) start start end end)))
        (otherwise (throw "element $element is not a block"))))

(function tryAutoConvert [element]
    (case element
        ((Block (objectWith source output outputStart outputEnd))
            (postMessage (objectWith [type "tryAutoConvert"] source output outputStart outputEnd)))
        (otherwise (throw "element $element is not a block"))))

(function tryFullAutoConvert []
    (postMessage (object type "tryFullAutoConvert")))

(function blockElements [source output locked idx]
    (let [outerDiv (document.createElement "div")
            :js.html.Element sourceDiv (cast (document.createElement "div"))
            :js.html.Element outputDiv (cast (document.createElement "div"))
            convertLink (document.createElement "a")
            xLink (document.createElement "a")
            lockLink (document.createElement "a")
            fullConvLink (document.createElement "a")
            nextBlankLink (document.createElement "a")
            blockLinkBefore (document.createElement "a")
            blockLinkAfter (document.createElement "a")
            joinBlocksLink (document.createElement "a")]
        (outerDiv.setAttribute "class" "container")
        (outerDiv.setAttribute "style" "display: flex;")

        (set blockLinkBefore.innerHTML "+")
        (blockLinkBefore.addEventListener "click"
            ->(insertBlockBeforeBlock (nth ktxt2Elements idx)))
        (set blockLinkAfter.innerHTML "+")
        (blockLinkAfter.addEventListener "click"
            ->(insertBlockAfterBlock (nth ktxt2Elements idx)))
        (set joinBlocksLink.innerHTML "join")
        (joinBlocksLink.addEventListener "click"
            ->(joinBlocks (nth ktxt2Elements idx) (nth ktxt2Elements (+ 1 idx))))

        (content.appendChild blockLinkBefore)
        (content.appendChild (document.createElement "br"))

        (monacoEditor sourceDiv "width: 50%;" source /* TODO get the real extension of the source file: */ "txt" locked
            ->editor (replaceSourceBlock (nth ktxt2Elements idx) (.replace (editor.getValue) "\r" "")))

        (monacoEditor outputDiv "flex-grow: 1;" output /* TODO get the real extension of the output file: */ "txt" locked
            ->editor (replaceOutputBlock (nth ktxt2Elements idx) (.replace (editor.getValue) "\r" "")))

        // Link that will delete the whole block:
        (set xLink.innerHTML "x")
        (xLink.addEventListener "click"
            ->(deleteEntireBlock (nth ktxt2Elements idx)))
        (unless locked
            (outerDiv.appendChild xLink))

        (outerDiv.appendChild sourceDiv)

        // Link that attempts automatic conversion of the source in a block:
        (unless locked
            (set convertLink.innerHTML ">")
            (convertLink.setAttribute "style" "width: 2ch;")
            (convertLink.addEventListener "click"
                ->(tryAutoConvert (nth ktxt2Elements idx)))
            (outerDiv.appendChild convertLink))

        (outerDiv.appendChild outputDiv)

        (set lockLink.innerHTML (if locked "unlock " "lock "))
        (lockLink.addEventListener "click"
            ->(changeLockStatus (nth ktxt2Elements idx) !locked))
        (outerDiv.appendChild lockLink)
        (set nextBlankLink.innerHTML "NextBlank")
        (nextBlankLink.addEventListener "click" nextBlankOutput)
        (outerDiv.appendChild nextBlankLink)
        (set fullConvLink.innerHTML "ConvertAll")
        (fullConvLink.addEventListener "click" tryFullAutoConvert)
        (outerDiv.appendChild fullConvLink)
        (content.appendChild outerDiv)
        (content.appendChild (document.createElement "br"))
        (content.appendChild blockLinkAfter)
        (when (nth ktxt2Elements (+ idx 1))
            (content.appendChild joinBlocksLink))))

(var &mut updatingContent false)

(function :Void setScrollY [y]
    (window.scroll
        (object
            left 0
            top y
            behavior INSTANT)))

(function :Void changeElementScrollY [:Void->Void changeFunc]
    (changeFunc)
    (clamp elementScrollY 0 (- ktxt2Elements.length PAGE_SIZE))
    (changeState s
        (set s.elementScrollY elementScrollY))
    (updateContent "scrolling through elements"))

(function :Void updateContent [:String reason &opt text]
    // (print "updating content because $reason")
    (try
            {
                (set updatingContent true)
                (when content
                    (set editors [])
                    (doFor e eventSubscriptions (e.dispose))
                    (set eventSubscriptions [])
                    (document.body.removeChild content))
                (set content (document.createElement "div"))
                (document.body.appendChild content)
                (when text (set ktxt2Elements (KTxt2.splitFileElements (Stream.fromString text))))
                (when (< 0 elementScrollY)
                    (let [upLink (document.createElement "a")
                            topLink (document.createElement "a")]
                        (set upLink.innerHTML "^ ")
                        (set topLink.innerHTML "^^^")
                        (upLink.addEventListener "click" pageUp)
                        (topLink.addEventListener "click" pageTop)
                        (content.appendChild upLink)
                        (content.appendChild topLink)))
                (doFor [idx element] (.slice (collect (enumerate ktxt2Elements)) elementScrollY (+ elementScrollY PAGE_SIZE))
                    (case element
                        ((Block (objectWith source output outputLocked))
                            (blockElements source output outputLocked idx))
                        (otherwise (throw "shouldn't happen"))))
                (when (> (- ktxt2Elements.length 1) (+ elementScrollY SCROLL_AMOUNT))
                    (let [downLink (document.createElement "a")
                            bottomLink (document.createElement "a")]
                        (set downLink.innerHTML "v ")
                        (set bottomLink.innerHTML "vvv")
                        (downLink.addEventListener "click" pageDown)
                        (bottomLink.addEventListener "click" pageBottom)
                        (content.appendChild downLink)
                        (content.appendChild bottomLink)))
                (set updatingContent false)
            }
        (catch [error] (print "Error updating ktxt2 editor: ${error}"))))

(function scrollToPageTop []
    (setScrollY 0))

(function scrollToPageBottom []
    (setScrollY (- document.body.scrollHeight document.documentElement.clientHeight)))

(function pageDown []
    (changeElementScrollY ->(+= elementScrollY SCROLL_AMOUNT))
    (scrollToPageTop))

(function nextBlankOutput []
    (doFor idx (range (+ 1 elementScrollY) ktxt2Elements.length)
        (case (nth ktxt2Elements idx)
            // TODO add unless guards to case
            ((when !(output.trim) (Block (objectWith output)))
                (changeElementScrollY ->(set elementScrollY idx))
                (scrollToPageTop)
                (break))
            (otherwise))))

(function pageBottom []
    (changeElementScrollY ->(set elementScrollY (- ktxt2Elements.length PAGE_SIZE)))
    (scrollToPageBottom))

(function pageUp []
    (changeElementScrollY ->(-= elementScrollY SCROLL_AMOUNT))
    (scrollToPageBottom))

(function pageTop []
    (changeElementScrollY ->(set elementScrollY 0))
    (scrollToPageTop))

(function export []
    (postMessage (object type "export")))

(function find []
    (postMessage (object type "find")))

(function findNext []
    (postMessage (object type "findNext")))

(defMacro __find []
    `(let [elem (nth ktxt2Elements idx)]
        (assertLet [(Block block) elem]
            (whenLet [(Some foundIdx) (indexOf (.toLowerCase "${block.source}${block.output}") (.toLowerCase text))]
                (changeElementScrollY ->(set elementScrollY idx))
                (return)))))

(function :Void _find [text]
    (let [startIdx elementScrollY]
        (doFor idx (range (+ 1 startIdx) ktxt2Elements.length)
            (__find))
        (doFor idx (range 0 (+ 1 startIdx))
            (__find))
            
        (print "No occurances of `${text}` were found.")))
