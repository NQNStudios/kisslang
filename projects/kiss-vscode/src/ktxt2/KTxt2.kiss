// Functions for parsing and modifying ktxt2 files.

// ktxt2 files contain an original "SOURCE" file and a translated "OUTPUT" file
// which is authored semi-automatically with the help of a custom VSCode editor.
// A file called README.md.html.ktxt2 would be for converting README.md -> README.html.

(var blockStartEnd "|||")
(var unlockedStart "|>|")
(var lockedStart "|!|")
(var outputStarts [unlockedStart lockedStart])
(var emptyBlock "${blockStartEnd}${unlockedStart}${blockStartEnd}")

(function :Array<KTxt2Element> splitFileElements [:Stream fileStream]
    (let [elements []]
        (loop
            (let [start
                        (fileStream.position)
                    block
                        (object
                            source ""
                            sourceStart null
                            sourceEnd null
                            output ""
                            outputStart null 
                            outputEnd null
                            outputLocked false)]
                // Look for the start of a KTxt2 block
                (case (fileStream.takeUntilOneOf [blockStartEnd] true)
                    ((Some comment)
                        // Anything before the start of the block used to be considered a comment
                        /*(when comment
                            (let [end (fileStream.position)]
                                (elements.push (Comment (object text comment start start end end)))))*/
                        (fileStream.dropChars blockStartEnd.length)
                        (when (fileStream.isEmpty) (break))
                        (let [sourceStartPosition (fileStream.position)
                                sourceBlock (fileStream.expect "A chunk of source text followed by one of $outputStarts"
                                                ->(fileStream.takeUntilOneOf outputStarts))
                                sourceEndPosition (fileStream.position)]
                            (set block.source sourceBlock)
                            (set block.sourceStart sourceStartPosition)
                            (set block.sourceEnd sourceEndPosition))
                        (assert (apply = (for outputStart outputStarts outputStart.length)) "all output starts must be the same length!")
                        (set block.outputLocked
                            (case (fileStream.expect "One of $outputStarts" ->(fileStream.takeChars .length (first outputStarts)))
                                (lockedStart true)
                                (unlockedStart false)
                                (otherwise
                                    (throw "Expected one of $outputStarts"))))
                        (let [outputStartPosition (fileStream.position)
                                outputBlock (fileStream.expect "A chunk of output text followed by $blockStartEnd"
                                                ->(fileStream.takeUntilOneOf [blockStartEnd]))
                                outputEndPosition (fileStream.position)]
                            (fileStream.dropChars blockStartEnd.length)
                            (set block.output outputBlock)
                            (set block.outputStart outputStartPosition)
                            (set block.outputEnd outputEndPosition)))
                    (None
                        (break)))
                (elements.push (Block block))))
            elements))

// Return [sourceFile outputFile]
(function :Array<String> extractFileContents [:Stream fileStream :String->Dynamic reportError]
    (let [&mut sourceText ""
            &mut outputText ""
            interp (new KissInterp)]
        (doFor ktxtElement (splitFileElements fileStream)
            (case ktxtElement
                ((Block (objectWith source output))
                    (+= sourceText source)
                    (dictSet interp.variables "source" source)
                    (dictSet interp.variables "R" re_flex.R)
                    (+= outputText
                        // Don't run the expensive "evalKiss" if there is no interpolation in the block!
                        (if (= -1 (output.indexOf "\$"))
                                output
                            (try (interp.evalKiss "\"${output}\"")
                                (catch [error] (reportError "Export templating error $error") (throw error))))))
                (otherwise)))
        [sourceText outputText]))

(function :Map<String,KTxt2Conversion> validConversions [:Array<KTxt2Conversion> conversions :String sourceFile :String outputFile :String source]
    (let [validMap (new Map)]
        (doFor c conversions
            (case c
                ((when (and
                            (= sourceType (sourceFile.extension))
                            (= outputType (outputFile.extension))
                            (canConvert source))
                        (objectWith sourceType outputType canConvert name))
                    (dictSet validMap name c))
                (otherwise {})))
        validMap))