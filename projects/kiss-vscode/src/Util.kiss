/**
 * Aliases
 */

// output 
(defAlias &call infoMessage Vscode.window.showInformationMessage)
(defAlias &call warningMessage Vscode.window.showWarningMessage)
(defAlias &call errorMessage Vscode.window.showErrorMessage)

// input
(defAlias &call inputBox Vscode.window.showInputBox)
(defAlias &call _quickPick Vscode.window.showQuickPick)

(function quickPickItem [label &opt description]
    (object
        label label
        description description
        detail null
        picked null
        alwaysShow null))

(function quickPick [:Array<String> strings]
    (awaitLet [chosenItem (_quickPick (for string strings (quickPickItem string)))]
        (when chosenItem chosenItem.label)))

(function :js.lib.Promise.Thenable<Dynamic> quickPickMap [:Map<String,Dynamic> stringMap]
    (awaitLet [chosenItem (_quickPick (for =>key value stringMap (quickPickItem key (Std.string value))))]
        (when chosenItem (dictGet stringMap chosenItem.label))))

// commands
(defAlias &call executeCommand Vscode.commands.executeCommand)
(function repeatCommand [command times]
    (let [iteration
                ->[&opt _] (executeCommand command)
            &mut promise
                (iteration)]
        (doFor i (range (- times 1))
            (set promise (promise.then iteration)))
        promise))

// Other

(defAlias &call showTextDocument Vscode.window.showTextDocument)
(defAlias &call openTextDocument Vscode.workspace.openTextDocument)

// Macros for implementing commands in Kiss

(defMacro withValueOrInputBox [v &body body]
    `(if ,v
            {,@body}
        (awaitLet [,v (inputBox)]
            ,@body)))

(defMacro withValueOrQuickPick [v options &body body]
    `(if ,v
            {,@body}
        (awaitLet [,v (quickPick ,options)]
            ,@body)))

(defMacro withValueOrQuickPickMap [v options &body body]
    `(if ,v
            {,@body}
        (awaitLet [,v (quickPickMap ,options)]
            ,@body)))

// This has to be a macro so it can return from tryLoadConfig
(defMacro trySpawnSync [command args options onError]
    `(let [command ,command
            args ,args
            options ,options
            result (ChildProcess.spawnSync command args options)]
        (if result.error
                {(,onError "Error $result.error from $command ${args}: $result.stdout $result.stderr")(return)}
            (case result.status 
                (0 null)
                (errCode
                    (,onError "Error code $errCode from $command ${args}: $result.stdout $result.stderr")
                    (return))
                (null (,onError "result status is null from $command ${args}: $result.stdout $result.stderr"))))))

(function :Void showCompileError [errorMessage]
    (ifLet [compileErrors (R.distinctMatches
                                            (R.group
                                                (R.namedGroup "file"
                                                    (R.repeat (R.oneOf R.anyLetter R.anyDigit (R.escape "/")) 1) // filename
                                                    (R.escape ".kiss:")
                                                    (R.repeat R.anyDigit 1) // line
                                                    (R.escape ":")
                                                    (R.optional
                                                        (R.group 
                                                            (R.repeat R.anyDigit 1) // column
                                                            (R.escape ":"))))
                                                (R.repeat R.anyChar 1))
                                            errorMessage)]
            {
                (Vscode.window.showErrorMessage errorMessage)
                (awaitLet [chosen (quickPickMap (for match compileErrors =>match.match match))]
                    (executeCommand "workbench.action.quickOpen" (substr (chosen.namedGroup "file") 0 -1)))
            }
        (Vscode.window.showErrorMessage errorMessage)))