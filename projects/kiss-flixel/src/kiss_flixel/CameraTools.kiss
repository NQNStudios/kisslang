(function updateKeyControl [:FlxCamera camera :Float elapsed :Float speed :Void->Bool leftKey :Void->Bool rightKey :Void->Bool upKey :Void->Bool downKey]
    (let [scrollAmount (* speed elapsed)
            &mut :FlxVector movement (new FlxPoint)]
        (when (leftKey) (-= movement.x 1))
        (when (rightKey) (+= movement.x 1))
        (when (upKey) (-= movement.y 1))
        (when (downKey) (+= movement.y 1))
        (when (< 0 movement.length)
            (set movement (movement.normalize)))
        (movement.scale scrollAmount)
        (+= camera.scroll.x movement.x)
        (+= camera.scroll.y movement.y)))

(var :Map<FlxCamera,FlxCamera> borderCameras (new Map))

// Add a border sprite on top of this camera's viewport, scaling the border to frame the viewport,
// and downsizing and shifting the viewport to fit within the border's opaque frame
(function addBorder [:FlxCamera camera :FlxSprite border]
    (let [borderCamera
                (new FlxCamera (Std.int camera.x) (Std.int camera.y) camera.width camera.height)
            :BitmapData borderPixels 
                (border.updateFramePixels)
            isTransparent
                ->c (= c FlxColor.TRANSPARENT)
            borderHorizontal
                (borderPixels.getVector (new Rectangle 0 (iHalf border.height) border.width 1))
            borderVertical
                (borderPixels.getVector (new Rectangle (iHalf border.width) 0 1 border.height))
            borderSizeLeft
                (borderHorizontal.findIndex isTransparent)
            borderSizeTop
                (borderVertical.findIndex isTransparent)
            borderSizeRight
                (.findIndex (borderHorizontal.reverse) isTransparent)
            borderSizeBottom
                (.findIndex (borderVertical.reverse) isTransparent)]
    (set border.x 0) // It will be 0,0 relative to its own camera
    (set border.y 0)
    (border.setGraphicSize camera.width camera.height)
    (border.updateHitbox)
    (FlxG.cameras.add borderCamera false)
    (dictSet borderCameras camera borderCamera)
    (set border.cameras [borderCamera])
    (set borderCamera.bgColor FlxColor.TRANSPARENT)
    (FlxG.state.add border)
    (let [dx (* border.scale.x borderSizeLeft)
            dy (* border.scale.y borderSizeTop)]
        (+= camera.x dx)
        (+= camera.y dy)
        (-= camera.width dx (* border.scale.x borderSizeRight))
        (-= camera.height dy (* border.scale.y borderSizeBottom)))))

(function updateMouseBorderControl [:FlxCamera camera :Float elapsed :Float speed :Float heightFraction]
    (let [viewport (ifLet [bc (dictGet borderCameras camera)] bc camera)
            left viewport.x
            top viewport.y
            right (+ viewport.x viewport.width)
            bottom (+ viewport.y viewport.height)
            // Use the same margin size for x and y, and calculate it based on height
            // (in a landscape view, this just makes more sense to me)
            margin (* viewport.height heightFraction)
            mPos (FlxG.mouse.getScreenPosition)]
        (updateKeyControl camera elapsed speed
            // when the camera takes the whole screen, count the letterbox zones as margin
            ->(if (= left 0)
                    (<= mPos.x (+ left margin))
                (<= left mPos.x (+ left margin)))
            ->(if (= right FlxG.width)
                    (<= (- right margin) mPos.x)
                (<= (- right margin) mPos.x right))
            ->(if (= top 0)
                    (<= mPos.y (+ top margin))
                (<= top mPos.y (+ top margin)))
            ->(if (= bottom FlxG.height)
                    (<= (- bottom margin) mPos.y)
                (<= (- bottom margin) mPos.y bottom)))))

(function updateScrollWheelZoom [:FlxCamera camera :Float elapsed :Float speed]
    #{
        if (FlxG.mouse.wheel != 0) {
            camera.zoom += (FlxG.mouse.wheel * elapsed * speed);
        }
    }#)

(function calculateScrollBounds <>[:FlxObject T] [:FlxCamera camera :FlxTypedGroup<T> group &opt :Float margin]
    (let [r (GroupTools.calculateBounds group margin)]
        (camera.setScrollBoundsRect r.x r.y r.width r.height)))

(function extendScrollBounds [:FlxCamera camera :FlxObject object &opt :Float margin]
    // if the given object is out of bounds, extend the bounds
    (let [r (object.getRotatedBounds)]
        (setMin camera.minScrollX (- r.left margin))
        (setMin camera.minScrollY (- r.top margin))
        (setMax camera.maxScrollX (+ r.right margin))
        (setMax camera.maxScrollY (+ r.bottom margin))))