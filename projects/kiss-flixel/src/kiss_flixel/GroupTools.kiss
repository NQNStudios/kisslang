(function :Void clearNulls <>[:FlxObject T] [:FlxTypedGroup<T> group]
    (while (contains group.members null)
        (group.members.splice (group.members.lastIndexOf null) 1)))

// Because FlxGroup will fill elements into null gaps in groups, this method inefficiently clears null gaps
(function :Void bringToFront <>[:FlxObject T] [:FlxTypedGroup<T> group :T obj]
    (group.remove obj true)
    (clearNulls group)
    (group.add obj))

// Because FlxGroup will fill elements into null gaps in groups, this method throws an error when a null gap is present
(function :Void sendToBack <>[:FlxObject T] [:FlxTypedGroup<T> group :T obj]
    (group.remove obj true)
    (group.insert 0 obj))

(function :FlxRect calculateBounds <>[:FlxObject T] [:FlxTypedGroup<T> group &opt :Float margin]
    (unless margin (set margin 0))
    (let [&mut minX 0
            &mut maxX 0
            &mut minY 0
            &mut maxY 0
            r (new FlxRect)]
        
        (group.forEach ->object
            (let [bounds (object.getRotatedBounds r)]
                (set minX (min minX bounds.left))
                (set minY (min minY bounds.top))
                (set maxX (max maxX bounds.right))
                (set maxY (max maxY bounds.bottom))))

        (r.fromTwoPoints
            (new FlxPoint (- minX margin) (- minY margin))
            (new FlxPoint (+ maxX margin) (+ maxY margin)))))