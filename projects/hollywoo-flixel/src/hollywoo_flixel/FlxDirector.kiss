(prop :FlxActionDigital continueAction) 
(prop actionManager (new FlxActionManager))
(prop &mut :Movie<FlxSprite,FlxScreenPosition,ActorFlxSprite,FlxSound,String,FlxSprite,FlxSound,FlxCamera> movie)
(defAlias &ident flxMovie (cast movie FlxMovie))
(loadFrom "hollywoo-flixel" "src/hollywoo_flixel/Aliases.kiss")

(prop :Array<FlxTypedGroup<FlxSprite>> spriteLayers [])
(var LAYER_MAX 5)

(defNew []
    (set continueAction (new FlxActionDigital "Continue" onContinue))
    // TODO allow configuring continue keys -- any key, specifically mapped keys, etc.
    (continueAction.addKey SPACE JUST_PRESSED)
    (continueAction.addMouse LEFT JUST_PRESSED)
    (actionManager.addAction continueAction)
    (FlxG.inputs.add actionManager)
    (set actionManager.resetOnStateSwitch NONE)
    
    // TODO characters will be in front of every prop layer -- characters need their own group layer
    (doFor i (range LAYER_MAX)
        (let [g (new FlxTypedGroup<FlxSprite>)]
            (spriteLayers.push g)
            (FlxG.state.add g))))

(method :Void showSet [:FlxSprite setSprite :SceneTime time :ScenePerspective perspective :Appearance appearance :FlxCamera camera :Continuation cc]
    (case appearance
        (FirstAppearance
            (setSprite.setGraphicSize FlxG.width)
            (when (> setSprite.height FlxG.height)
                (setSprite.setGraphicSize 0 FlxG.height))
            (setSprite.updateHitbox)
            (setSprite.screenCenter))
        (otherwise))
    (FlxG.cameras.remove flxMovie.uiCamera false)
    (FlxG.cameras.remove flxMovie.screenCamera false)
    (FlxG.cameras.add camera)
    (FlxG.cameras.add flxMovie.screenCamera)
    (FlxG.cameras.add flxMovie.uiCamera)
    (set setSprite.cameras [camera])
    (FlxG.state.add setSprite)
    (cc))

(method :Void hideSet [:FlxSprite set :FlxCamera camera :Continuation cc]
    (FlxG.cameras.remove camera false)
    (FlxG.state.remove set)
    (cc))

(method :Void cleanup [] 0)

(method :Option<AutoZConfig> autoZConfig [] (Some (object zPerLayer flxMovie.STAGE_BEHIND_DY frontLayer 0)))

(method :Void showCharacter [:Character<ActorFlxSprite> character :Appearance appearance :FlxCamera camera :Continuation cc]
    // TODO on the first appearance, show name and description (maybe? also probably not for all?)
    // TODO  also allow for manually defined flipped frames so text on clothing doesn't mirror
    (set character.actor.cameras [camera])
    (set character.actor.flipX ?!(= character.stageFacing character.actor.defaultFacing))
    // All actors same width, display centered on x
    (character.actor.setGraphicSize flxMovie.ACTOR_WIDTH)
    (character.actor.updateHitbox)
    (set character.actor.x
        (- character.stagePosition.x
            (/ character.actor.width 2)))
    (set character.actor.y character.stagePosition.y)
    // Bump sprites up from the bottom if they're too tall
    (let [bottom (+ character.actor.y character.actor.height)]
        (when (> bottom FlxG.height)
            (-= character.actor.y (- bottom FlxG.height))))
    // Display with y adjusted by z:
    (-= character.actor.y character.stagePosition.z)
    (FlxG.state.add character.actor)
    (cc))

(method :Void hideCharacter [:Character<ActorFlxSprite> character :FlxCamera camera :Continuation cc]
    (FlxG.state.remove character.actor)
    (cc))

(prop &mut :Null<Continuation> nextCC)
(method onContinue [:FlxActionDigital continueAction]
    (whenLet [cc nextCC]
        (set nextCC null)
        (cc)))

(method :Void startWaitForInput [:Continuation cc]
    (set nextCC cc))

(method :Void stopWaitForInput [:Continuation cc]
    (when (= nextCC cc)
        (set nextCC null)))

(var TITLE_Y 240)
(var TITLE_SIZE 72)
(var TITLE_MARGIN 100)
(var SUBTITLES_MARGIN 30)
(var SUBTITLES_SIZE 48)
(prop &mut :FlxSprite titleCard null)
(method :Void showTitleCard [:Array<String> text :Continuation cc]
    (set titleCard (new FlxSprite))
    (titleCard.makeGraphic FlxG.width FlxG.height FlxColor.BLACK true)
    (SpriteTools.writeOnSprite (text.shift) TITLE_SIZE titleCard (object x (Percent 0.5) y (Pixels TITLE_Y)))
    (localVar &mut subtitleY (+ TITLE_Y TITLE_SIZE TITLE_MARGIN))
    (doFor subtitle text
        (SpriteTools.writeOnSprite subtitle SUBTITLES_SIZE titleCard (object x (Percent 0.5) y (Pixels subtitleY)))
        (+= subtitleY SUBTITLES_SIZE SUBTITLES_MARGIN))
    (FlxG.state.add titleCard)
    // Allow skipping
    (startWaitForInput cc))

(method :Void hideTitleCard []
    (FlxG.state.remove titleCard))


// TODO these could be customizable to the Actor, wrylies, etc.
(var DIALOG_BOX_COLOR FlxColor.BLACK)
(var DIALOG_COLOR FlxColor.WHITE)
(var DIALOG_SIZE 24)

(prop &mut :FlxSprite dialogBox)
(prop &mut :FlxText dialogText)
(prop &mut :FlxText speakerNameText)

(method showDialog [:String speakerName :SpeechType<ActorFlxSprite> type :String wryly :String text :Continuation cc]
    // TODO handle text messages, wrylies, off-screen, from-phone, etc. via (case type)
    // TODO attribute on-screen dialogue to the character's stageposition

    // TODO allow sounds for wrylies, like the dispatch click
    (localVar &mut nameOnRight false)
    (case type
        ((OnScreen character)
            (when (> character.stagePosition.x (/ FlxG.width 2))
                (set nameOnRight true))
            // When an actor is associated with the line, check for an animation matching the wryly
            (let [actor (the ActorFlxSprite character.actor)]
                (if wryly
                        (actor.playAnimation wryly)
                    (actor.playAnimation "neutral"))))
        ((or (OffScreen actor) (VoiceOver actor) (TextMessage actor) (FromPhone actor) (Custom _ actor _))
            (if wryly
                        (actor.playAnimation wryly)
                    (actor.playAnimation "neutral")))
        (otherwise))

    // Make a dialog box
    (unless dialogBox
        (set dialogBox (new FlxSprite flxMovie.DIALOG_X flxMovie.DIALOG_Y))
        (dialogBox.makeGraphic flxMovie.DIALOG_WIDTH flxMovie.DIALOG_HEIGHT DIALOG_BOX_COLOR))
    
    (set dialogBox.cameras [flxMovie.uiCamera])
    (FlxG.state.add dialogBox)
    (dialogBox.revive)
    // show the dialog
    (unless dialogText
        (set dialogText (new FlxText flxMovie.DIALOG_X flxMovie.DIALOG_Y flxMovie.DIALOG_WIDTH "" DIALOG_SIZE)))
    (set dialogText.cameras [flxMovie.uiCamera])
    (FlxG.state.add dialogText)
    (set dialogText.text text)
    // TODO actually page through the dialog instead of sizing it down?
    // ^ though that doesn't work automatically with VO unless individual word times are kept in the json
    // (which would be really clunky)
    (set dialogText.size DIALOG_SIZE)
    (while (< FlxG.height (+ dialogText.y dialogText.height))
        (-= dialogText.size 6))
    // show the speaker name
    (unless speakerNameText
        (set speakerNameText (new FlxText flxMovie.DIALOG_X flxMovie.DIALOG_Y 0 "" DIALOG_SIZE)))
    (set speakerNameText.cameras [flxMovie.uiCamera])
    (FlxG.state.add speakerNameText)
    (if speakerName
            {
                (set speakerNameText.text "${speakerName}:")
                (set speakerNameText.x (if nameOnRight (- (+ flxMovie.DIALOG_X flxMovie.DIALOG_WIDTH) speakerNameText.fieldWidth) flxMovie.DIALOG_X))
                (speakerNameText.revive)
                (set dialogText.y (+ flxMovie.DIALOG_Y speakerNameText.height))
            }
        (set dialogText.y flxMovie.DIALOG_Y))
    (dialogText.revive)
    (startWaitForInput cc))

(method :Void hideDialog []
    (dialogText.kill)
    (speakerNameText.kill)
    (dialogBox.kill))

(method :Void playSound [:FlxSound sound :Float volumeMod :Bool waitForEnd :Continuation cc]
    (let [originalVolume sound.volume
            restoreOriginalVolume ->(set sound.volume originalVolume)]
        (*= sound.volume volumeMod)
        (set sound.onComplete 
            (if waitForEnd
                    ->{(restoreOriginalVolume) (cc)}
                restoreOriginalVolume)))
    (sound.play)
    (unless waitForEnd (cc)))

(method :Void stopSound [:FlxSound sound]
    (sound.stop))

(var DELAY_BETWEEN_VOICE_TRACKS 0.1)
(prop :Map<FlxSound,Function> restoreOriginalVolumes (new Map))
(method :Void playVoiceTrack [:FlxSound track :Float volumeMod :Float start :Float end :Continuation cc]
    (let [originalVolume track.volume
            restoreOriginalVolume ->(set track.volume originalVolume)]
        (dictSet restoreOriginalVolumes track restoreOriginalVolume)
        (*= track.volume volumeMod)
        (set track.onComplete ->{(restoreOriginalVolume) (movie.delay DELAY_BETWEEN_VOICE_TRACKS cc)}))
    (track.play true (* 1000 start) (* 1000 end)))

(method :Void stopVoiceTrack [:FlxSound track]
    (track.stop)
    ((dictGet restoreOriginalVolumes track)))

(prop &mut :FlxSound music)
(prop MUSIC_FADE_SEC 1)
(prop MUSIC_FADE_STEPS 10)
(method :Void playSong [:String song :Float volumeMod :Bool loop :Bool waitForEnd :Continuation cc]
    (set music (FlxG.sound.play song 0 loop null true (if waitForEnd cc ->{})))
    (.start (new FlxTimer)
        (/ MUSIC_FADE_SEC MUSIC_FADE_STEPS)
        ->:Void _ (+= music.volume (/ volumeMod MUSIC_FADE_STEPS))
        MUSIC_FADE_STEPS)
    (set music.persist true)
    (unless waitForEnd (cc)))

(method :Void stopSong [] (when music (music.stop)))

(var PROP_MIN_WIDTH 200)
(var PROP_MAX_WIDTH 500)

(method :Void quickShowPropOnScreen [:FlxSprite prop :FlxScreenPosition position :Continuation cc]
    (let [left (/ FlxG.width 6)
            right (- FlxG.width left)
            upper (/ FlxG.height 6)
            lower (- FlxG.height upper)
            centerX (/ FlxG.width 2)
            centerY (/ FlxG.height 2)
            [x y]
                (case position
                    (Center [centerX centerY])
                    (UpperLeft [left upper])
                    (UpperRight [right upper])
                    (LowerLeft [left lower])
                    (LowerRight [right lower])
                    (LowerCenter [centerX lower])
                    (UpperCenter [centerX upper])
                    (otherwise (throw "screen position not implemented")))]
        (let [width (min (max prop.width PROP_MIN_WIDTH) PROP_MAX_WIDTH)]
            (prop.setGraphicSize width)

            (prop.updateHitbox)
            // if the prop is too tall, shrink it heightwise
            (when (> prop.height flxMovie.DIALOG_Y)
                (prop.setGraphicSize 0 (Std.int flxMovie.DIALOG_Y))
                (prop.updateHitbox))

            (set prop.x (- x (/ prop.width 2)))
            (set prop.y (- y (/ prop.height 2)))

            (let [propBottom (+ prop.y prop.height)]
                (case position 
                    // if a prop meant to be centered would block the dialogue box, bump it up
                    (Center
                            (when (> propBottom flxMovie.DIALOG_Y)
                                (-= prop.y (- propBottom flxMovie.DIALOG_Y))))
                    // If a prop meant to be on the lower half of the screen goes below the edge, bring it up
                    ((or LowerLeft LowerCenter LowerRight)
                        (when (> propBottom FlxG.height)
                            (-= prop.y (- propBottom FlxG.height))))
                    (otherwise)))

            (FlxG.state.add prop)))
    (cc))

(prop &mut :FlxSprite _canvas null)
(method :FlxSprite canvas []
    (unless _canvas
        (set _canvas (new FlxSprite 0 0))
        (_canvas.makeGraphic FlxG.width FlxG.height FlxColor.BLACK))
    _canvas)
        
(method :Void smartShowPropOnScreen [:FlxSprite prop :Int layer :RelativePosition rpos :Continuation cc]
    (assert (<= 0 layer LAYER_MAX) "Layer $layer is out of range 0-$LAYER_MAX")
    (SpriteTools.scaleStampOn prop (canvas) rpos)
    (let [[x y] (SpriteTools.positionOn prop (canvas) rpos)]
        (set prop.x x)
        (set prop.y y)
        (if (= layer LAYER_MAX)
                // In front of everything:    
                (FlxG.state.add prop)
            (.add (nth spriteLayers layer) prop)))
    (cc))

(method :Void showPropOnScreen [:FlxSprite prop :FlxScreenPosition position :Continuation cc]
    (set prop.cameras [flxMovie.screenCamera])
    // TODO give the prop reveal some time to land (add a delay to the cc)
    (ifLet [(FullControl layer rpos) position]
            (smartShowPropOnScreen prop layer rpos cc)
        (quickShowPropOnScreen prop position cc)))

(method :Void hideProp [:FlxSprite prop cc]
    (FlxG.state.remove prop)
    (doFor layer spriteLayers
        (layer.remove prop))
    (cc))

(prop :Array<FlxText> creditsText [])
(method _ctext [:String text :Int size]
    (let [t (new FlxText 0 0 0 text size)]
        (creditsText.push t)
        t))

(prop &mut :FlxSprite blackBG null)
(method :Void showBlackScreen []
    (set blackBG (new FlxSprite))
    (blackBG.makeGraphic FlxG.width FlxG.height FlxColor.BLACK true)
    (FlxG.state.add blackBG))

(method :Void hideBlackScreen []
    (FlxG.state.remove blackBG))

// TODO maybe credits need their own substate so an after-credits scene could be done.
// currently the bg will cover whatever the final scene was.
(method :Void rollCredits [:Array<CreditsLine> credits cc]
    (localVar bg (new FlxSprite))
    (bg.makeGraphic FlxG.width FlxG.height FlxColor.BLACK true)
    (FlxG.state.add bg)
    (localVar &mut textY FlxG.height)
    (var oneColSize 64)
    (var twoColSize 48)
    (var threeColSize 32)
    (var creditMargin 10)
    (var twoColumnGap 50)
    (doFor line credits
        (case line
            (Break
                (+= textY oneColSize))
            // Centered, big one column lines
            ((OneColumn col1)
                (let [t (_ctext col1 oneColSize)]
                    (t.screenCenter)
                    (set t.y textY))
                (+= textY oneColSize creditMargin))
            // Centered left/right two column lines
            ((TwoColumn col1 col2)
                (let [t1 (_ctext col1 twoColSize)
                        t2 (_ctext col2 twoColSize)]
                    (set t1.x (- (* FlxG.width 0.3) t1.width (/ twoColumnGap 2)))
                    (set t1.y textY)
                    (set t2.x (+ (* FlxG.width 0.3) (/ twoColumnGap 2)))
                    (set t2.y textY))
                (+= textY twoColSize creditMargin))
            // Left-justified, centered, right-justified three column lines
            ((ThreeColumn col1 col2 col3)
                (let [t1 (_ctext col1 threeColSize)
                        t2 (_ctext col2 threeColSize)
                        t3 (_ctext col3 threeColSize)]
                    (set t1.x creditMargin)
                    (set t1.y textY)
                    (t2.screenCenter)
                    (set t2.y textY)
                    (set t3.x (- FlxG.width creditMargin t3.width))
                    (set t3.y textY))
                (+= textY threeColSize creditMargin))
            (otherwise)))
    
    (doFor text creditsText
        (FlxG.state.add text)
        (FlxTween.linearMotion text text.x text.y text.x (- text.y textY) 200 false (object onComplete ->:Void _ (cc)))))