(defun main []
    // Day 1
    (let [p (pairWithSum 2020 [1721 979 366 299 675 1456])]
        (unless (and (has p 1721) (has p 299))
            (throw "pairWithSum is broken")))
    (let [[a b] (pairWithSum 2020 (Util.readInts "src/year2020/inputs/day1-1.txt"))]
        (unless (= 545379 (* a b))
            (throw "pairWithSum is broken")))
    (let [t (trioWithSum 2020 [1721 979 366 299 675 1456])]
        (unless (and (has t 675) (has t 366) (has t 979))
            (throw "trioWithSum is broken")))
    (let [[a b c] (trioWithSum 2020 (Util.readInts "src/year2020/inputs/day1-1.txt"))]
        (unless (= 257778836 (* a b c))
            (throw "trioWithSum is broken")))
            
    // Day 2
    (unless (Passwords.validateInputLine "1-3 a: abcde" Passwords.parsePasswordCheck1)
        (throw "parsePasswordCheck1 is broken"))
    (when (Passwords.validateInputLine "1-3 b: cdefg" Passwords.parsePasswordCheck1)
        (throw "parsePasswordCheck1 is broken"))
    (unless (Passwords.validateInputLine "2-9 c: ccccccccc" Passwords.parsePasswordCheck1)
        (throw "parsePasswordCheck1 is broken"))
    (unless (= 655 (count (map (Util.readLines "src/year2020/inputs/day2-1.txt") (.bind Passwords.validateInputLine _ Passwords.parsePasswordCheck1)) (lambda [v] v)))
        (throw "parsePasswordCheck1 is broken"))
    (unless (Passwords.validateInputLine "1-3 a: abcde" Passwords.parsePasswordCheck2)
        (throw "parsePasswordCheck2 is broken"))
    (when (Passwords.validateInputLine "1-3 b: cdefg" Passwords.parsePasswordCheck2)
        (throw "parsePasswordCheck2 is broken"))
    (when (Passwords.validateInputLine "2-9 c: ccccccccc" Passwords.parsePasswordCheck2)
        (throw "parsePasswordCheck2 is broken"))
    (unless (= 673 (count (map (Util.readLines "src/year2020/inputs/day2-1.txt") (.bind Passwords.validateInputLine _ Passwords.parsePasswordCheck2)) (lambda [v] v)))
        (throw "parsePasswordCheck2 is broken")))

(defun :kiss.List<Int> pairWithSum [sum :kiss.List<Int> numbers]
    // Put the numbers in a map for random access. This gives an O(n) solution
    (deflocal :Map<Int,Int> numbersMap (new Map))
    (doFor number numbers
        (dict-set numbersMap number (- sum number))
        (let [requiredForPair (dict-get numbersMap number)]
            (when (numbersMap.exists requiredForPair)
                (return [number requiredForPair]))))
    null)

(defun :kiss.List<Int> trioWithSum [sum :kiss.List<Int> numbers]
    (doFor number numbers
        (let [requiredForTrio (- sum number)
                pairThatSatisfies (pairWithSum requiredForTrio numbers)]
            (when pairThatSatisfies
                (return [number (nth pairThatSatisfies 0) (nth pairThatSatisfies 1)]))))
    null)